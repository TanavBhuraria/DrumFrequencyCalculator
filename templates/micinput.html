<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Professional Drum Frequency Analyzer — Fixed</title>
  <style>
    /* (kept your original styling mostly intact) */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: linear-gradient(135deg,#1a1a2e,#16213e);
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-x: hidden;
    }
    .container { max-width: 800px; width: 100%; display:flex; flex-direction:column; align-items:center; }
    header { text-align:center; margin-bottom:30px; padding:20px; width:100%; position:relative; }
    h1 { font-size:2.2rem; background:linear-gradient(90deg,#ff7e5f,#feb47b); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
    .back-btn { position:absolute; top:20px; left:20px; background:rgba(255,255,255,0.1); color:#ff7e5f; border:none; padding:10px 15px; border-radius:50px; cursor:pointer; display:flex; gap:6px; align-items:center; }
    .subtitle { font-size:1.05rem; color:#a0a0d0; margin-top:10px; max-width:600px; }
    .visualization { width:100%; height:200px; background:rgba(0,0,0,0.3); border-radius:12px; margin-bottom:20px; position:relative; overflow:hidden; box-shadow:0 8px 32px rgba(0,0,0,0.3); }
    .drum-display { position:absolute; bottom:0; width:100%; height:100%; display:flex; justify-content:center; align-items:flex-end; gap:10px; padding:20px; pointer-events:none; }
    .drum-pad { pointer-events:none; width:70px; height:70px; background:rgba(255,255,255,0.08); border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:0.9rem; color:rgba(255,255,255,0.8); transition:all 150ms; }
    .drum-pad.active { transform:scale(1.2); background:rgba(255,126,95,0.85); box-shadow:0 0 20px rgba(255,126,95,0.6); }
    .controls { display:flex; gap:12px; margin-bottom:16px; flex-wrap:wrap; justify-content:center; }
    button { background:linear-gradient(135deg,#ff7e5f,#feb47b); color:white; border:none; padding:12px 20px; font-size:1rem; border-radius:50px; cursor:pointer; min-width:140px; }
    button:disabled { background:#555; cursor:not-allowed; }
    .stats { display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:18px; width:100%; margin-bottom:20px; }
    .stat-card { background:rgba(255,255,255,0.05); border-radius:12px; padding:18px; text-align:center; }
    .stat-value { font-size:2.4rem; font-weight:700; background:linear-gradient(90deg,#ff7e5f,#feb47b); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
    .settings { background:rgba(255,255,255,0.04); border-radius:12px; padding:18px; width:100%; margin-bottom:20px; }
    .slider-container { margin-bottom:12px; }
    .slider-container label { display:flex; justify-content:space-between; color:#a0a0d0; margin-bottom:8px; }
    input[type="range"] { width:100%; }
    .canvas-container { width:100%; height:150px; margin-top:10px; background:rgba(0,0,0,0.2); border-radius:8px; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }
    .harmonic-display { margin-top:10px; background:rgba(0,0,0,0.2); border-radius:10px; padding:12px; width:100%; }
    .harmonic-list { display:grid; grid-template-columns:repeat(4,1fr); gap:8px; }
    .harmonic-item { background:rgba(255,255,255,0.03); padding:8px; border-radius:8px; text-align:center; }
    .spectrum-display { margin-top:12px; width:100%; display:flex; gap:2px; align-items:flex-end; height:120px; background:rgba(0,0,0,0.15); border-radius:8px; padding:8px; }
    .spectrum-bar { flex:1; min-width:3px; border-radius:3px 3px 0 0; background:linear-gradient(to top,#ff7e5f,#feb47b); transition:height 0.08s; }
    .frequency-range { display:flex; justify-content:space-between; margin-top:8px; color:#a0a0d0; font-size:0.85rem; }
    .debug-panel { background:rgba(0,0,0,0.7); color:#fff; padding:12px; border-radius:8px; width:100%; font-family:monospace; margin-bottom:12px; }
    .debug-row { display:flex; justify-content:space-between; margin-bottom:6px; }
    .info-box { background:rgba(255,126,95,0.08); padding:10px; border-radius:8px; margin-top:10px; width:100%; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <button class="back-btn">◀ Back</button>
      <h1>Professional Drum Frequency Analyzer</h1>
      <p class="subtitle">Accurate frequency analysis for drum tuning and sound engineering</p>
    </header>

    <div class="debug-panel">
      <div class="debug-row"><div>Status:</div><div><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#4caf50;margin-right:8px"></span>Ready</div></div>
      <div class="debug-row"><div>FFT Size:</div><div id="fftSize">8192</div></div>
      <div class="debug-row"><div>Sensitivity:</div><div id="sensitivityLabel">0.10</div></div>
      <div class="debug-row"><div>Min Frequency:</div><div id="minFreq">20 Hz</div></div>
    </div>

    <div class="visualization">
      <canvas id="spectrumCanvas"></canvas>
      <div class="drum-display"></div>
    </div>

    <div class="controls">
      <button id="startBtn">Start Analysis</button>
      <button id="stopBtn" disabled>Stop Analysis</button>
    </div>

    <div class="settings">
      <div class="slider-container">
        <label>Sound Sensitivity <span id="sensitivityValueDisplay">0.10</span></label>
        <input id="sensitivitySlider" type="range" min="0.05" max="0.15" step="0.005" value="0.10">
      </div>
    </div>

    <div class="stats">
      <div class="stat-card">
        <h2>Fundamental Frequency</h2>
        <div class="stat-value" id="fundamentalFreq">-- Hz</div>
      </div>
      <div class="stat-card">
        <h2>Peak Amplitude</h2>
        <div class="stat-value" id="peakAmplitude">-- dB</div>
      </div>
      <div class="stat-card">
        <h2>Signal Confidence</h2>
        <div style="margin-top:10px;width:100%;background:rgba(255,255,255,0.08);border-radius:6px;height:8px;overflow:hidden">
          <div class="confidence-level" style="width:0%;height:100%;background:linear-gradient(90deg,#f44336,#4caf50);"></div>
        </div>
        <div style="display:flex;justify-content:space-between;margin-top:6px;color:#a0a0d0;font-size:0.85rem"><span>Low</span><span id="confidenceValue">0%</span><span>High</span></div>
      </div>
    </div>

    <div class="harmonic-display">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px"><h3 style="margin:0">Harmonic Analysis</h3><small style="color:#a0a0d0">1×, 2×, 3×, 4×</small></div>
      <div class="harmonic-list">
        <div class="harmonic-item"><div class="harmonic-label">1st</div><div class="harmonic-value" id="harmonic1">-- Hz</div></div>
        <div class="harmonic-item"><div class="harmonic-label">2nd</div><div class="harmonic-value" id="harmonic2">-- Hz</div></div>
        <div class="harmonic-item"><div class="harmonic-label">3rd</div><div class="harmonic-value" id="harmonic3">-- Hz</div></div>
        <div class="harmonic-item"><div class="harmonic-label">4th</div><div class="harmonic-value" id="harmonic4">-- Hz</div></div>
      </div>
    </div>

    <div class="spectrum-display" id="spectrumDisplay"></div>
    <div class="frequency-range">
      <span>20 Hz</span>
      <span>200 Hz</span>
      <span>2 kHz</span>
      <span>20 kHz</span>
    </div>

    <div class="info-box">
      <div style="font-weight:bold;color:#ff7e5f;margin-bottom:6px">Low Frequency Fix Applied</div>
      <div>Using float FFT data, linear magnitude conversion and parabolic interpolation to detect fundamentals down to ~20Hz more reliably.</div>
    </div>

    <footer style="margin-top:18px;color:#888">Professional Drum Frequency Analyzer v2.1 — Fixed</footer>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // DOM
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const fundamentalFreqEl = document.getElementById('fundamentalFreq');
      const peakAmplitudeEl = document.getElementById('peakAmplitude');
      const confidenceValueEl = document.getElementById('confidenceValue');
      const confidenceLevelEl = document.querySelector('.confidence-level');
      const spectrumDisplay = document.getElementById('spectrumDisplay');
      const spectrumCanvas = document.getElementById('spectrumCanvas');
      const canvasCtx = spectrumCanvas.getContext('2d');
      const fftSizeLabel = document.getElementById('fftSize');
      const sensitivitySlider = document.getElementById('sensitivitySlider');
      const sensitivityValueDisplay = document.getElementById('sensitivityValueDisplay');
      const harmonicEls = {
        1: document.getElementById('harmonic1'),
        2: document.getElementById('harmonic2'),
        3: document.getElementById('harmonic3'),
        4: document.getElementById('harmonic4'),
      };

      // Audio vars
      let audioContext = null;
      let analyser = null;
      let microphone = null;
      let mediaStream = null; // store real MediaStream so we can stop it later
      let isRecording = false;
      let animationId = null;
      let floatDataArray = null;
      let spectrumBarsCount = 64;

      // init UI
      fftSizeLabel.textContent = 8192;
      sensitivityValueDisplay.textContent = parseFloat(sensitivitySlider.value).toFixed(3);

      // set canvas pixel ratio
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const w = spectrumCanvas.clientWidth;
        const h = spectrumCanvas.clientHeight;
        spectrumCanvas.width = Math.max(1, Math.floor(w * dpr));
        spectrumCanvas.height = Math.max(1, Math.floor(h * dpr));
        canvasCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // initialize spectrum bars
      function initSpectrumBars() {
        spectrumDisplay.innerHTML = '';
        for (let i = 0; i < spectrumBarsCount; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.height = '5px';
          spectrumDisplay.appendChild(bar);
        }
      }
      initSpectrumBars();

      // drum pads (demo)
      const drumNames = ['Kick','Snare','Hi-Hat','Tom 1','Tom 2','Floor Tom','Ride','Crash'];
      const drumDisplay = document.querySelector('.drum-display');
      drumNames.forEach(name => {
        const pad = document.createElement('div');
        pad.className = 'drum-pad';
        pad.textContent = name;
        drumDisplay.appendChild(pad);
      });

      // demo pad animation moved AFTER pads exist
      setInterval(() => {
        if (!isRecording) return;
        const pads = document.querySelectorAll('.drum-pad');
        if (!pads.length) return;
        const idx = Math.floor(Math.random() * pads.length);
        pads[idx].classList.add('active');
        setTimeout(() => pads[idx].classList.remove('active'), 150);
      }, 1500);

      // sensitivity control
      let sensitivity = parseFloat(sensitivitySlider.value); // 0.05 - 0.15
      sensitivitySlider.addEventListener('input', (e) => {
        sensitivity = parseFloat(e.target.value);
        sensitivityValueDisplay.textContent = sensitivity.toFixed(3);
        document.getElementById('sensitivityLabel').textContent = sensitivity.toFixed(2);
      });

      // Start / Stop
      startBtn.addEventListener('click', startAnalysis);
      stopBtn.addEventListener('click', stopAnalysis);

      async function startAnalysis() {
        if (isRecording) return;
        try {
          if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();

          if (audioContext.state === 'suspended') await audioContext.resume();

          // stop any previous media stream safely
          if (mediaStream) {
            mediaStream.getTracks().forEach(t => t.stop());
            mediaStream = null;
          }
          if (microphone) {
            try { microphone.disconnect(); } catch(e) {}
            microphone = null;
          }

          // create analyser
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 8192; // bigFFT for low-frequency resolution
          analyser.minDecibels = -100;
          analyser.maxDecibels = -10;
          analyser.smoothingTimeConstant = 0.6;
          const bufferLength = analyser.frequencyBinCount;
          floatDataArray = new Float32Array(bufferLength);

          // get stream
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaStream = stream;
          microphone = audioContext.createMediaStreamSource(stream);
          microphone.connect(analyser);

          isRecording = true;
          startBtn.disabled = true;
          stopBtn.disabled = false;

          resizeCanvas();
          visualize();
        } catch (err) {
          console.error('Start failed:', err);
          alert('Could not start audio. Check microphone permissions.');
        }
      }

      function stopAnalysis() {
        if (!isRecording) return;
        isRecording = false;

        if (microphone) {
          try { microphone.disconnect(); } catch(e) {}
          microphone = null;
        }
        if (mediaStream) {
          mediaStream.getTracks().forEach(t => t.stop());
          mediaStream = null;
        }
        if (analyser) {
          try { analyser.disconnect(); } catch(e) {}
          analyser = null;
        }
        if (audioContext) {
          audioContext.close().catch(()=>{}).finally(() => { audioContext = null; });
        }

        startBtn.disabled = false;
        stopBtn.disabled = true;

        if (animationId) cancelAnimationFrame(animationId);
        animationId = null;
        fundamentalFreqEl.textContent = '-- Hz';
        peakAmplitudeEl.textContent = '-- dB';
        confidenceValueEl.textContent = '0%';
        confidenceLevelEl.style.width = '0%';
      }

      // Utility: convert bin -> frequency resolution
      function binToFreq(bin, sampleRate, fftSize) {
        return bin * (sampleRate / fftSize);
      }

      // analyze fundamentals using float FFT data and linear mags
      function analyzeFundamentalFrequency(floatDbArray, sampleRate, fftSize) {
        const bufferLength = floatDbArray.length;
        // convert dB -> linear amplitude (20 * log10 -> amplitude)
        const mags = new Float32Array(bufferLength);
        let maxMag = 0;
        for (let i = 0; i < bufferLength; i++) {
          // floatDbArray contains negative dB values (e.g. -80..-10)
          const db = floatDbArray[i];
          const lin = Math.pow(10, db / 20); // linear amplitude
          mags[i] = lin;
          if (lin > maxMag) maxMag = lin;
        }
        if (maxMag === 0) maxMag = 1e-12;

        // frequency resolution
        const freqRes = sampleRate / fftSize;
        const minBin = Math.max(2, Math.floor(20 / freqRes)); // >=20Hz
        const lowFreqMaxBin = Math.min(bufferLength - 2, Math.floor(300 / freqRes)); // up to 300Hz

        // find local peaks in the low band with normalized magnitude threshold (user sensitivity)
        const normalized = new Float32Array(bufferLength);
        for (let i = minBin; i <= lowFreqMaxBin; i++) normalized[i] = mags[i] / maxMag;

        const peakCandidates = [];
        for (let i = minBin; i <= lowFreqMaxBin; i++) {
          // local peak & above sensitivity threshold
          if (normalized[i] > normalized[i - 1] && normalized[i] > normalized[i + 1] && normalized[i] >= sensitivity) {
            peakCandidates.push({ bin: i, norm: normalized[i], mag: mags[i], db: 20 * Math.log10(mags[i] + 1e-12), freq: i * freqRes });
          }
        }

        // take top 6 by norm
        peakCandidates.sort((a, b) => b.norm - a.norm);
        const topPeaks = peakCandidates.slice(0, 6);

        // validate by checking harmonics and compute confidence
        const validated = topPeaks.map(p => {
          let harmonicScore = 0;
          for (let h = 2; h <= 4; h++) {
            const hBin = Math.round((p.bin * h));
            if (hBin < bufferLength && normalized[hBin] >= p.norm * 0.25) {
              harmonicScore++;
            }
          }
          // parabolic interpolation (using linear mag values)
          let refinedFreq = p.freq;
          const b = p.bin;
          if (b > 1 && b < bufferLength - 1) {
            const left = mags[b - 1], center = mags[b], right = mags[b + 1];
            const denom = (left - 2 * center + right);
            if (Math.abs(denom) > 1e-12) {
              const delta = 0.5 * (left - right) / denom; // shift in bins
              refinedFreq = (b + delta) * freqRes;
            }
          }
          // confidence scale: normalized peak * 80 + harmonic*5 (cap 100)
          const confidence = Math.min(100, Math.round(p.norm * 80 + harmonicScore * 5));
          return { ...p, harmonicScore, refinedFreq, confidence };
        });

        // choose best: highest confidence, prefer at least one harmonic
        validated.sort((a, b) => {
          if (b.confidence !== a.confidence) return b.confidence - a.confidence;
          return b.norm - a.norm;
        });

        const best = validated[0] || null;

        if (!best) return { frequency: 0, confidence: 0, peakDb: null };

        return { frequency: best.refinedFreq, confidence: best.confidence, peakDb: best.db };
      }

      // main visualization loop
      function visualize() {
        if (!isRecording || !analyser || !audioContext) return;
        animationId = requestAnimationFrame(visualize);

        const bufferLength = analyser.frequencyBinCount; // fftSize/2
        if (!floatDataArray || floatDataArray.length !== bufferLength) floatDataArray = new Float32Array(bufferLength);
        analyser.getFloatFrequencyData(floatDataArray);

        // analyze fundamentals
        const analysis = analyzeFundamentalFrequency(floatDataArray, audioContext.sampleRate, analyser.fftSize);
        const fundamentalFrequency = analysis.frequency || 0;
        const confidence = analysis.confidence || 0;

        // Update UI
        if (fundamentalFrequency > 0) {
          fundamentalFreqEl.textContent = fundamentalFrequency.toFixed(1) + ' Hz';
        } else {
          fundamentalFreqEl.textContent = '-- Hz';
        }
        if (analysis.peakDb !== null) {
          peakAmplitudeEl.textContent = analysis.peakDb.toFixed(0) + ' dB';
        } else {
          peakAmplitudeEl.textContent = '-- dB';
        }
        confidenceValueEl.textContent = confidence + '%';
        confidenceLevelEl.style.width = confidence + '%';

        for (let i = 1; i <= 4; i++) {
          if (fundamentalFrequency > 0) harmonicEls[i].textContent = (fundamentalFrequency * i).toFixed(1) + ' Hz';
          else harmonicEls[i].textContent = '-- Hz';
        }

        // draw spectrum bars (log-ish mapping to show low freqs better)
        const spectrumBars = spectrumDisplay.querySelectorAll('.spectrum-bar');
        const bars = spectrumBars.length;
        const sampleRate = audioContext.sampleRate;
        const freqRes = sampleRate / analyser.fftSize;

        for (let i = 0; i < bars; i++) {
          // place bins with quadratic allocation to emphasize lows
          const bin = Math.floor(Math.pow(i / bars, 2) * bufferLength);
          const db = floatDataArray[bin] || -130;
          const lin = Math.pow(10, db / 20);
          // map lin (very small) to visual height
          const height = Math.max(3, Math.min(120, (lin * 300) )); // tweak multiplier for visible range
          spectrumBars[i].style.height = height + 'px';

          // highlight approximate fundamental bin
          const fundBin = Math.floor(fundamentalFrequency / freqRes);
          if (Math.abs(bin - fundBin) <= 1 && fundamentalFrequency > 0) {
            spectrumBars[i].style.background = 'linear-gradient(to top,#4caf50,#8bc34a)';
          } else {
            spectrumBars[i].style.background = 'linear-gradient(to top,#ff7e5f,#feb47b)';
          }
        }

        // draw frequency waveform-style bars on canvas for detail
        canvasCtx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
        const drawBins = bufferLength;
        const canvasW = spectrumCanvas.width / (window.devicePixelRatio || 1);
        const canvasH = spectrumCanvas.height / (window.devicePixelRatio || 1);
        const barW = canvasW / Math.min(512, drawBins);
        let x = 0;
        const maxDraw = Math.min(drawBins, 512);
        for (let i = 0; i < maxDraw; i++) {
          const db = floatDataArray[i];
          const lin = Math.pow(10, db / 20);
          const h = Math.max(1, (lin * canvasH * 1.2));
          const isLow = i < (drawBins / 6);
          canvasCtx.fillStyle = isLow ? `rgba(255,126,95,${Math.min(1, (lin*4))})` : `rgba(254,180,123,${Math.min(1, (lin*2))})`;
          canvasCtx.fillRect(x, canvasH - h, barW, h);
          x += barW;
        }
      }
    });
  </script>
</body>
</html>
