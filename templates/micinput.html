<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Drum Classifier — Snare(1)/Toms(2)/Kick(3)</title>
<style>
  body{background:#111827;color:#fff;font-family:Segoe UI,system-ui,Arial,sans-serif;display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;margin:0;padding:18px;text-align:center}
  h1{color:#f59e0b;margin-bottom:8px}
  button{background:#0ea5e9;border:none;padding:12px 20px;border-radius:10px;color:#022;cursor:pointer;font-weight:700;margin-bottom:12px}
  .result{font-size:2.4rem;font-weight:800;color:#f59e0b;margin:8px 0;min-height:48px}
  .sub{color:#9ca3af;margin-bottom:6px}
  .debug{font-family:monospace;font-size:0.86rem;color:#cbd5e1;margin-top:12px;white-space:pre-wrap;text-align:left;max-width:700px}
</style>
</head>
<body>
  <h1>Drum Classifier</h1>
  <button id="btn">Start</button>
  <div class="sub">Outputs: <strong>1 = Snare</strong>, <strong>2 = Toms</strong>, <strong>3 = Kick</strong>, <strong>unknown</strong></div>
  <div class="result" id="label">idle</div>
  <div class="debug" id="dbg">debug: not running</div>

<script>
/*
Conservative Drum Classifier (snare=1, toms=2, kick=3)
Strategy:
 - Use AnalyserNode with large fftSize for spectrum (low freq resolution).
 - Continuous gating (mean absolute) to detect hits (onset).
 - On each onset: capture current spectrum (getByteFrequencyData) and compute:
    - E_low  (20-150 Hz)
    - E_mid  (150-800 Hz)
    - E_high (800-6000 Hz)
    - spectral centroid, spectral flatness, tonalPeak frequency
 - Apply conservative rule set:
    - Kick (3): E_low dominant (low/mid ratio high), centroid low, tonalPeak low
    - Snare (1): mid+high broadband (flatness high), centroid higher, energy spread
    - Toms (2): mid-tonal energy dominant, clear tonal peak in mid band
 - If ambiguous, return 'unknown' (prevents mislabels).
*/
document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('btn');
  const labelEl = document.getElementById('label');
  const dbg = document.getElementById('dbg');

  let audioCtx = null, analyser = null, src = null, script = null;
  let isRunning = false;
  // params
  const FFT_SIZE = 32768; // large for good low-frequency resolution
  const PROCESSOR = 2048;
  let sr = 44100;

  // gating & adapt noise floor
  let noiseEMA = 0.002;
  const EMA_ALPHA = 0.02;
  const MIN_MEANABS = 0.0005;
  const HIT_MULT = 2.2; // meanAbs must be > noiseEMA * HIT_MULT

  // hit debounce
  let lastHit = 0;
  const HIT_DEBOUNCE_MS = 80;

  // classification smoothing (small history)
  const HISTORY = 5;
  const classBuffer = [];

  btn.addEventListener('click', async () => {
    if (isRunning) { stop(); btn.textContent='Start'; labelEl.textContent='idle'; dbg.textContent='stopped'; }
    else { await start(); btn.textContent='Stop'; }
  });

  async function start() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sr = audioCtx.sampleRate;
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = Math.min(FFT_SIZE, 32768);
    analyser.smoothingTimeConstant = 0.0;

    script = audioCtx.createScriptProcessor(PROCESSOR, 1, 1);
    script.onaudioprocess = onAudioProcess;

    const stream = await navigator.mediaDevices.getUserMedia({ audio: { channelCount:1, echoCancellation:false, noiseSuppression:false, autoGainControl:false }});
    src = audioCtx.createMediaStreamSource(stream);
    src.connect(analyser);
    src.connect(script);
    script.connect(audioCtx.destination);

    isRunning = true;
    dbg.textContent = 'running — sampleRate: ' + sr + ' fftSize: ' + analyser.fftSize;
  }

  function stop() {
    try { src.mediaStream.getTracks().forEach(t => t.stop()); } catch(e){}
    try { script.disconnect(); analyser.disconnect(); audioCtx.close(); } catch(e){}
    audioCtx = analyser = src = script = null;
    isRunning = false;
    classBuffer.length = 0;
  }

  function onAudioProcess(ev) {
    if (!analyser) return;
    const bufferLen = analyser.fftSize;
    // quick time-domain gating: use analyser.getByteTimeDomainData
    const timeBytes = new Uint8Array(bufferLen);
    analyser.getByteTimeDomainData(timeBytes);
    // convert meanAbs quickly
    let sumAbs = 0;
    for (let i=0;i<bufferLen;i++) sumAbs += Math.abs((timeBytes[i]-128)/128);
    const meanAbs = sumAbs / bufferLen;
    // update noise floor
    noiseEMA = noiseEMA * (1 - EMA_ALPHA) + meanAbs * EMA_ALPHA;
    const thr = Math.max(MIN_MEANABS, noiseEMA * HIT_MULT);
    const now = performance.now();
    // detect onset when meanAbs exceeds threshold and debounced
    if (meanAbs >= thr && (now - lastHit) > HIT_DEBOUNCE_MS) {
      lastHit = now;
      classifyHit(meanAbs, thr);
    } else {
      // clear label after HOLD if no hits in a bit
      if (lastHit && (now - lastHit) > 600) labelEl.textContent = 'idle';
    }
  }

  function classifyHit(meanAbs, thr) {
    // get frequency spectrum snapshot
    const freqLen = analyser.frequencyBinCount;
    const freqBytes = new Uint8Array(freqLen);
    analyser.getByteFrequencyData(freqBytes); // bytes 0..255 ~ magnitude
    const binSize = sr / analyser.fftSize;

    // compute band energies (sum of mags) and some features
    const E = {low:0, mid:0, high:0, full:0};
    const lowRange = [20,150];
    const midRange = [150,800];
    const highRange = [800,6000];
    let maxMag = 0, maxBin = 0;
    let sumWeightedFreq = 0; // for centroid numerator
    let sumMag = 0;
    for (let i=1;i<freqLen;i++){
      const f = i * binSize;
      const m = freqBytes[i];
      sumMag += m;
      sumWeightedFreq += m * f;
      if (m > maxMag){ maxMag = m; maxBin = i; }
      E.full += m;
      if (f >= lowRange[0] && f <= lowRange[1]) E.low += m;
      else if (f > midRange[0] && f <= midRange[1]) E.mid += m;
      else if (f > highRange[0] && f <= highRange[1]) E.high += m;
    }
    const centroid = sumMag > 0 ? (sumWeightedFreq / sumMag) : 0;
    // spectral flatness (approx) — ratio geometric mean / arithmetic mean; for bytes approximate by small transform
    // compute log-mean of magnitudes (avoid zeros)
    let logSum = 0, nonzero = 0;
    for (let i=1;i<freqLen;i++){ const v = Math.max(1, freqBytes[i]); logSum += Math.log(v); nonzero++; }
    const geoMean = Math.exp(logSum / Math.max(1, nonzero));
    const arithMean = sumMag / Math.max(1, freqLen-1);
    const flatness = arithMean > 0 ? (geoMean / arithMean) : 0; // closer to 1 => noise-like broadband

    // tonal peak frequency
    const peakFreq = maxBin * binSize;

    // normalize energies to avoid absolute-scale sensitivity
    const eLow = E.low;
    const eMid = E.mid;
    const eHigh = E.high;
    const eFull = E.full || 1;
    const lowRatio = eLow / eFull;
    const midRatio = eMid / eFull;
    const highRatio = eHigh / eFull;

    // Decision rules (conservative)
    // Compute some heuristics
    // Kick candidate: strong low energy ratio and centroid low
    const isKickScore = (lowRatio > 0.45 && centroid < 200) ? 1 : 0; // strong low energy -> kick
    // Tom candidate: mid energy dominant and has tonal peak in mid band
    const isTomScore = (midRatio > 0.35 && peakFreq >= 80 && peakFreq <= 500 && flatness < 0.6) ? 1 : 0;
    // Snare candidate: broadband mid+high energy, high flatness (noise-like), centroid higher
    const isSnareScore = ((midRatio + highRatio) > 0.55 && flatness > 0.45 && centroid > 300) ? 1 : 0;

    // Additional safe checks to avoid overlap:
    // If two scores tie or none pass, mark unknown.
    let chosen = 'unknown';
    let chosenId = null;

    const scores = {kick:isKickScore, tom:isTomScore, snare:isSnareScore};
    // prefer kick if exclusively kick-like
    if (scores.kick && !scores.tom && !scores.snare) { chosen = 'kick'; chosenId = 3; }
    else if (scores.tom && !scores.kick && !scores.snare) { chosen = 'toms'; chosenId = 2; }
    else if (scores.snare && !scores.kick && !scores.tom) { chosen = 'snare'; chosenId = 1; }
    else {
      // No exclusive winner — use graded thresholds & tie-breakers (conservative)
      // If lowRatio massively dominant -> kick
      if (lowRatio > 0.6 && centroid < 220 && eLow > eMid*1.8) { chosen = 'kick'; chosenId = 3; }
      // If tonal peak in mid band and mid ratio relatively strong -> tom
      else if (peakFreq >= 100 && peakFreq <= 450 && midRatio > 0.35 && flatness < 0.6) { chosen = 'toms'; chosenId = 2; }
      // If energy spread high and flatness indicates noise -> snare
      else if ( (midRatio + highRatio) > 0.6 && flatness > 0.42 && centroid > 280) { chosen = 'snare'; chosenId = 1; }
      else {
        // ambiguous — to avoid wrong labels, set unknown
        chosen = 'unknown';
        chosenId = null;
      }
    }

    // Post-check: ensure no obvious contradictions (e.g., cymbal/hihat: very high centroid or very high flatness)
    if (centroid > 3000 || highRatio > 0.7 && flatness > 0.6) {
      // probably cymbal/hihat — classify as unknown (we don't want to label cymbal as kick/tom/snare)
      chosen = 'unknown';
      chosenId = null;
    }

    // Buffer smoothing: push to history, use majority to reduce flicker
    classBuffer.push(chosenId === null ? 'unknown' : chosenId);
    if (classBuffer.length > HISTORY) classBuffer.shift();
    const counts = classBuffer.reduce((acc, v) => { acc[v] = (acc[v]||0)+1; return acc; }, {});
    // pick majority if any element > half
    let majority = null;
    for (const k in counts) {
      if (counts[k] > Math.floor(HISTORY/2)) { majority = k; break; }
    }
    const finalLabel = majority !== null ? majority : (chosenId === null ? 'unknown' : chosenId);

    // Update UI
    labelEl.textContent = (finalLabel === 'unknown') ? 'unknown' : `${finalLabel}`;
    // debug output helpful for tuning
    dbg.textContent = [
      `meanAbs:${meanAbs.toFixed(4)} thr:${thr.toFixed(4)} noiseEMA:${noiseEMA.toFixed(4)}`,
      `E_low:${eLow.toFixed(1)} E_mid:${eMid.toFixed(1)} E_high:${eHigh.toFixed(1)} full:${eFull.toFixed(1)}`,
      `ratios low/mid/high: ${(lowRatio).toFixed(2)}/${(midRatio).toFixed(2)}/${(highRatio).toFixed(2)}`,
      `centroid:${centroid.toFixed(1)} peakFreq:${peakFreq.toFixed(1)} flatness:${flatness.toFixed(2)}`,
      `scores: kick=${scores.kick} tom=${scores.tom} snare=${scores.snare}`,
      `chosen:${chosen} -> id:${chosenId === null ? 'unknown' : chosenId}`,
      `final:${finalLabel}`
    ].join('\n');

    // Done.
  }

});
</script>
</body>
</html>
