<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Professional Drum Analyzer</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 800px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      width: 100%;
      position: relative;
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      background: linear-gradient(90deg, #ff7e5f, #feb47b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .back-btn {
      position: absolute;
      top: 30px;
      left: 30px;
      background: rgba(255, 255, 255, 0.1);
      color: #ff7e5f;
      border: none;
      padding: 10px 18px;
      border-radius: 50px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 5px;
      z-index: 10;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    
    .back-btn:hover {
      background: rgba(255, 126, 95, 0.2);
      transform: translateY(-2px);
    }
    
    .back-btn svg {
      width: 16px;
      height: 16px;
      fill: #ff7e5f;
    }
    
    .subtitle {
      font-size: 1.2rem;
      color: #a0a0d0;
      max-width: 600px;
      margin: 0 auto;
      margin-top: 15px;
    }
    
    .visualization {
      width: 100%;
      height: 200px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      margin-bottom: 30px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .drum-display {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      gap: 10px;
      padding: 20px;
    }
    
    .drum-pad {
      width: 70px;
      height: 70px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2rem;
      font-weight: bold;
      color: rgba(255, 255, 255, 0.7);
      transition: all 50ms ease-out;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      will-change: transform, background-color;
    }
    
    .drum-pad.active {
      transform: scale(1.2);
      background: rgba(255, 126, 95, 0.8);
      box-shadow: 0 0 20px rgba(255, 126, 95, 0.7);
    }
    
    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    button {
      background: linear-gradient(135deg, #ff7e5f, #feb47b);
      color: white;
      border: none;
      padding: 14px 28px;
      font-size: 1.1rem;
      font-weight: 600;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 126, 95, 0.4);
      min-width: 180px;
    }
    
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(255, 126, 95, 0.6);
    }
    
    button:disabled {
      background: #555;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      width: 100%;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 25px;
      text-align: center;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .stat-card h2 {
      font-size: 1.3rem;
      margin-bottom: 15px;
      color: #a0a0d0;
    }
    
    .stat-value {
      font-size: 3.5rem;
      font-weight: 700;
      background: linear-gradient(90deg, #ff7e5f, #feb47b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .settings {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 25px;
      width: 100%;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .slider-container {
      margin-bottom: 20px;
    }
    
    .slider-container label {
      display: block;
      margin-bottom: 10px;
      font-size: 1.1rem;
      color: #a0a0d0;
      display: flex;
      justify-content: space-between;
    }
    
    .slider-container span {
      font-weight: bold;
      color: #ff7e5f;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ff7e5f;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(255, 126, 95, 0.7);
    }
    
    .canvas-container {
      width: 100%;
      height: 150px;
      margin-top: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }
    
    canvas {
      width: 100%;
      height: 100%;
    }
    
    .hit-indicator {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .hit-indicator.active {
      opacity: 1;
    }
    
    .harmonic-display {
      margin-top: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      padding: 15px;
      width: 100%;
    }
    
    .harmonic-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
    }
    
    .harmonic-header:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .harmonic-content {
      display: none;
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
    }
    
    .harmonic-content.show {
      display: block;
    }
    
    .harmonic-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 10px;
    }
    
    .harmonic-item {
      background: rgba(255, 255, 255, 0.05);
      padding: 10px;
      border-radius: 8px;
      text-align: center;
      transition: transform 0.2s;
    }
    
    .harmonic-item:hover {
      transform: translateY(-3px);
      background: rgba(255, 255, 255, 0.1);
    }
    
    .harmonic-label {
      font-size: 0.9rem;
      color: #a0a0d0;
      margin-bottom: 5px;
    }
    
    .harmonic-value {
      font-size: 1.2rem;
      font-weight: bold;
      color: #ff7e5f;
    }
    
    .drum-info {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      padding: 15px;
      margin-top: 20px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .drum-info-title {
      font-size: 1.2rem;
      margin-bottom: 10px;
      color: #ff7e5f;
    }
    
    .drum-info-text {
      text-align: center;
      color: #a0a0d0;
      line-height: 1.6;
      max-width: 600px;
    }
    
    footer {
      margin-top: 40px;
      text-align: center;
      color: #777;
      font-size: 0.9rem;
      padding: 20px;
    }
    
    .debug-panel {
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      width: 100%;
      font-family: monospace;
    }
    
    .debug-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    
    .debug-label {
      color: #a0a0d0;
    }
    
    .debug-value {
      font-weight: bold;
    }
    
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }
    
    .status-active {
      background-color: #4caf50;
    }
    
    .status-inactive {
      background-color: #f44336;
    }
    
    .chart-container {
      width: 100%;
      height: 150px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      overflow: hidden;
      margin-top: 20px;
    }
    
    .confidence-bar {
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      margin-top: 10px;
      overflow: hidden;
    }
    
    .confidence-level {
      height: 100%;
      background: linear-gradient(90deg, #f44336, #4caf50);
      border-radius: 3px;
      transition: width 0.3s ease;
    }
    
    .confidence-label {
      display: flex;
      justify-content: space-between;
      margin-top: 5px;
      font-size: 0.8rem;
      color: #a0a0d0;
    }
    
    .tools-row {
      display: flex;
      gap: 15px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    
    .tool-btn {
      background: rgba(255, 255, 255, 0.05);
      color: #a0a0d0;
      border: none;
      padding: 8px 15px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s;
    }
    
    .tool-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }
    
    .tool-btn.active {
      background: rgba(255, 126, 95, 0.2);
      color: #ff7e5f;
    }
    
    .spectrum-display {
      margin-top: 20px;
      height: 120px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      padding: 10px;
      display: flex;
      align-items: flex-end;
      justify-content: space-around;
      gap: 2px;
    }
    
    .spectrum-bar {
      flex: 1;
      background: linear-gradient(to top, #ff7e5f, #feb47b);
      border-radius: 3px 3px 0 0;
      min-width: 3px;
      transition: height 0.1s;
    }
    
    @media (max-width: 600px) {
      h1 {
        font-size: 2.2rem;
      }
      
      .stat-value {
        font-size: 2.8rem;
      }
      
      .drum-pad {
        width: 50px;
        height: 50px;
        font-size: 1rem;
      }
      
      button {
        min-width: 140px;
        padding: 12px 20px;
        font-size: 1rem;
      }
      
      .controls {
        gap: 10px;
      }
      
      .back-btn {
        top: 15px;
        left: 15px;
        padding: 8px 14px;
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <button class="back-btn">
        <svg viewBox="0 0 24 24">
          <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path>
        </svg>
        Back
      </button>
      <h1>Professional Drum Analyzer</h1>
      <p class="subtitle">Advanced drum detection with YIN frequency analysis</p>
    </header>
    
    <div class="visualization">
      <div class="drum-display">
        <div class="drum-pad" data-type="kick">KICK</div>
        <div class="drum-pad" data-type="snare">SNARE</div>
        <div class="drum-pad" data-type="hihat">HI-HAT</div>
        <div class="drum-pad" data-type="tom">TOM</div>
        <div class="drum-pad" data-type="cymbal">CYMBAL</div>
      </div>
    </div>
    
    <div class="controls">
      <button id="start-btn">Start Microphone</button>
      <button id="stop-btn" disabled>Stop Microphone</button>
      <button id="reset-btn">Reset Counter</button>
    </div>
    
    <div class="stats">
      <div class="stat-card">
        <h2>Hits Detected</h2>
        <div id="hits" class="stat-value">0</div>
      </div>
      
      <div class="stat-card">
        <h2>Detected Frequency</h2>
        <div id="frequency" class="stat-value">-- Hz</div>
      </div>
    </div>
    
    <div class="debug-panel">
      <div class="debug-row">
        <span class="debug-label">Microphone Status:</span>
        <span id="mic-status"><span class="status-indicator status-inactive"></span>Inactive</span>
      </div>
      <div class="debug-row">
        <span class="debug-label">Current Volume:</span>
        <span id="current-volume" class="debug-value">0.00</span>
      </div>
      <div class="debug-row">
        <span class="debug-label">Detection Threshold:</span>
        <span id="threshold" class="debug-value">0.05</span>
      </div>
      <div class="debug-row">
        <span class="debug-label">Last Drum Type:</span>
        <span id="last-drum" class="debug-value">--</span>
      </div>
      <div class="debug-row">
        <span class="debug-label">Detection Confidence:</span>
        <span id="confidence" class="debug-value">--</span>
      </div>
      <div class="confidence-bar">
        <div id="confidence-level" class="confidence-level" style="width: 0%"></div>
      </div>
      <div class="confidence-label">
        <span>Low</span>
        <span>High</span>
      </div>
    </div>
    
    <div class="settings">
      <div class="slider-container">
        <label>
          Detection Sensitivity
          <span id="sensitivity-val">0.05</span>
        </label>
        <input type="range" id="sensitivity-slider" min="0.01" max="0.15" step="0.01" value="0.05">
      </div>
      
      <div class="canvas-container">
        <canvas id="waveform"></canvas>
      </div>
      
      <div class="chart-container">
        <canvas id="volume-chart"></canvas>
      </div>
      
      <div class="spectrum-display" id="spectrum-display"></div>
      
      <div class="tools-row">
        <button class="tool-btn" id="toggle-wave">Waveform</button>
        <button class="tool-btn" id="toggle-spectrum">Spectrum</button>
        <button class="tool-btn" id="toggle-harmonics">Harmonics</button>
      </div>
    </div>
    
    <div class="harmonic-display">
      <div class="harmonic-header" id="harmonic-toggle">
        <h3>Harmonic Analysis</h3>
        <span>▼</span>
      </div>
      <div class="harmonic-content" id="harmonic-content">
        <div class="harmonic-list">
          <div class="harmonic-item">
            <div class="harmonic-label">Fundamental</div>
            <div class="harmonic-value" id="harmonic-fundamental">-- Hz</div>
          </div>
          <div class="harmonic-item">
            <div class="harmonic-label">2nd Harmonic</div>
            <div class="harmonic-value" id="harmonic-second">-- Hz</div>
          </div>
          <div class="harmonic-item">
            <div class="harmonic-label">3rd Harmonic</div>
            <div class="harmonic-value" id="harmonic-third">-- Hz</div>
          </div>
          <div class="harmonic-item">
            <div class="harmonic-label">4th Harmonic</div>
            <div class="harmonic-value" id="harmonic-fourth">-- Hz</div>
          </div>
          <div class="harmonic-item">
            <div class="harmonic-label">5th Harmonic</div>
            <div class="harmonic-value" id="harmonic-fifth">-- Hz</div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="drum-info">
      <div class="drum-info-title">Advanced Drum Analysis</div>
      <div class="drum-info-text">
        This analyzer uses YIN frequency detection for accurate drum identification. 
        The confidence indicator shows how certain the detection is. 
        For best results, position the microphone close to the drum source.
      </div>
    </div>
  </div>
  
  <div class="hit-indicator" id="hit-indicator"></div>
  
  <footer>
    <p>Professional Drum Analyzer | Enhanced Edition</p>
  </footer>

  <script>
    // DOM Elements
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const resetBtn = document.getElementById('reset-btn');
    const hitsEl = document.getElementById('hits');
    const freqEl = document.getElementById('frequency');
    const sensitivitySlider = document.getElementById('sensitivity-slider');
    const sensitivityVal = document.getElementById('sensitivity-val');
    const hitIndicator = document.getElementById('hit-indicator');
    const waveformCanvas = document.getElementById('waveform');
    const volumeCanvas = document.getElementById('volume-chart');
    const drumPads = document.querySelectorAll('.drum-pad');
    const micStatus = document.getElementById('mic-status');
    const currentVolume = document.getElementById('current-volume');
    const thresholdEl = document.getElementById('threshold');
    const lastDrumEl = document.getElementById('last-drum');
    const confidenceEl = document.getElementById('confidence');
    const confidenceLevel = document.getElementById('confidence-level');
    const harmonicToggle = document.getElementById('harmonic-toggle');
    const harmonicContent = document.getElementById('harmonic-content');
    const harmonicFundamental = document.getElementById('harmonic-fundamental');
    const harmonicSecond = document.getElementById('harmonic-second');
    const harmonicThird = document.getElementById('harmonic-third');
    const harmonicFourth = document.getElementById('harmonic-fourth');
    const harmonicFifth = document.getElementById('harmonic-fifth');
    const spectrumDisplay = document.getElementById('spectrum-display');
    const toggleWave = document.getElementById('toggle-wave');
    const toggleSpectrum = document.getElementById('toggle-spectrum');
    const toggleHarmonics = document.getElementById('toggle-harmonics');
    const backBtn = document.querySelector('.back-btn');
    
    // Audio variables
    let audioCtx = null;
    let analyser = null;
    let analyserSpectrum = null;
    let source = null;
    let mediaStream = null;
    let dataArray = null;
    let spectrumArray = null;
    let animationId = null;
    let bufferLength = null;
    
    // State variables
    let running = false;
    let hitCount = 0;
    let lastDrumType = null;
    let lastHitTime = 0;
    let lastFrequency = 0;
    let confidence = 0;
    const HIT_COOLDOWN = 200; // ms
    
    // Volume history for visualization
    const volumeHistory = new Array(100).fill(0);
    let currentIndex = 0;
    
    // Noise floor tracking
    let noiseFloor = 0.005;
    let noiseSamples = 0;
    const MAX_NOISE_SAMPLES = 100;
    
    // Drum detection history for smoothing
    const drumHistory = [];
    const HISTORY_SIZE = 5;
    
    // Initialize UI
    sensitivityVal.textContent = sensitivitySlider.value;
    thresholdEl.textContent = sensitivitySlider.value;
    
    // Create spectrum bars
    for (let i = 0; i < 64; i++) {
      const bar = document.createElement('div');
      bar.className = 'spectrum-bar';
      bar.style.height = '1px';
      spectrumDisplay.appendChild(bar);
    }
    
    // Event listeners
    startBtn.addEventListener('click', startMic);
    stopBtn.addEventListener('click', stopMic);
    resetBtn.addEventListener('click', resetCounter);
    sensitivitySlider.addEventListener('input', updateSensitivity);
    harmonicToggle.addEventListener('click', toggleHarmonicsPanel);
    toggleWave.addEventListener('click', () => toggleTool(toggleWave));
    toggleSpectrum.addEventListener('click', () => toggleTool(toggleSpectrum));
    toggleHarmonics.addEventListener('click', () => toggleTool(toggleHarmonics));
    backBtn.addEventListener('click', () => {
      alert('Back to index functionality would go here');
    });
    
    // Visual feedback for drum hit
    function showDrumHit(drumType) {
      const profile = getDrumProfile(drumType);
      
      // Pad animation
      drumPads.forEach(pad => {
        if (pad.dataset.type === drumType) {
          pad.classList.add('active');
          setTimeout(() => pad.classList.remove('active'), profile.decay);
        }
      });
      
      // Screen flash
      hitIndicator.style.background = `radial-gradient(circle, ${profile.color}77 0%, transparent 70%)`;
      hitIndicator.classList.add('active');
      setTimeout(() => hitIndicator.classList.remove('active'), profile.decay);
      
      // Update last drum display
      lastDrumEl.textContent = drumType.toUpperCase();
    }
    
    // Get drum profile
    function getDrumProfile(drumType) {
      return {
        kick: { range: [30, 100], color: '#ff5e5e', decay: 150 },
        snare: { range: [100, 300], color: '#5effae', decay: 120 },
        hihat: { range: [3000, 8000], color: '#5eb3ff', decay: 80 },
        tom: { range: [80, 200], color: '#ffbe5e', decay: 100 },
        cymbal: { range: [3000, 10000], color: '#d85eff', decay: 60 }
      }[drumType];
    }
    
    // Draw waveform visualization
    function drawWaveform() {
      if (!analyser || !running) return;
      
      analyser.getFloatTimeDomainData(dataArray);
      
      const ctx = waveformCanvas.getContext('2d');
      ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
      ctx.beginPath();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#ff7e5f';
      ctx.filter = 'blur(0.5px)';
      
      const sliceWidth = waveformCanvas.width / bufferLength;
      let x = 0;
      
      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i];
        const y = waveformCanvas.height/2 + (v * waveformCanvas.height/2);
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
        
        x += sliceWidth;
      }
      
      ctx.stroke();
      ctx.filter = 'none';
    }
    
    // Draw volume chart
    function drawVolumeChart() {
      const ctx = volumeCanvas.getContext('2d');
      ctx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);
      
      // Draw threshold line
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255, 126, 95, 0.5)';
      ctx.lineWidth = 2;
      const thresholdY = volumeCanvas.height - (parseFloat(sensitivitySlider.value) * volumeCanvas.height * 10);
      ctx.moveTo(0, thresholdY);
      ctx.lineTo(volumeCanvas.width, thresholdY);
      ctx.stroke();
      
      // Draw volume line
      ctx.beginPath();
      ctx.strokeStyle = '#4caf50';
      ctx.lineWidth = 2;
      
      for (let i = 0; i < volumeHistory.length; i++) {
        const x = (i / volumeHistory.length) * volumeCanvas.width;
        const y = volumeCanvas.height - (volumeHistory[i] * volumeCanvas.height * 10);
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      ctx.stroke();
    }
    
    // Draw spectrum visualization
    function drawSpectrum() {
      if (!analyserSpectrum || !running) return;
      
      analyserSpectrum.getByteFrequencyData(spectrumArray);
      const bars = spectrumDisplay.querySelectorAll('.spectrum-bar');
      const barCount = bars.length;
      
      for (let i = 0; i < barCount; i++) {
        const value = spectrumArray[i];
        const percent = value / 255;
        const height = Math.max(1, percent * 100);
        bars[i].style.height = `${height}%`;
        
        // Color based on drum type
        if (i < 10) {
          bars[i].style.background = 'linear-gradient(to top, #ff5e5e, #ff7e5f)'; // Kick
        } else if (i < 20) {
          bars[i].style.background = 'linear-gradient(to top, #5effae, #7effb3)'; // Snare
        } else if (i < 30) {
          bars[i].style.background = 'linear-gradient(to top, #ffbe5e, #ffd17e)'; // Tom
        } else {
          bars[i].style.background = 'linear-gradient(to top, #5eb3ff, #7ec7ff)'; // Hi-hat/cymbal
        }
      }
    }
    
    // Improved frequency detection using YIN algorithm
    function detectFundamental(buffer, sampleRate) {
      // Implementation of the YIN pitch detection algorithm
      const yinBuffer = new Float32Array(buffer.length);
      const threshold = 0.15;
      
      yinBuffer[0] = 1;
      
      // Compute difference function
      for (let tau = 1; tau < buffer.length/2; tau++) {
        yinBuffer[tau] = 0;
        for (let j = 0; j < buffer.length/2; j++) {
          const delta = buffer[j] - buffer[j + tau];
          yinBuffer[tau] += delta * delta;
        }
      }
      
      // Compute cumulative mean normalized difference
      yinBuffer[0] = 1;
      let runningSum = 0;
      for (let tau = 1; tau < buffer.length/2; tau++) {
        runningSum += yinBuffer[tau];
        yinBuffer[tau] = yinBuffer[tau] * tau / runningSum;
      }
      
      // Find the first valley below threshold
      let tau;
      for (tau = 2; tau < buffer.length/2; tau++) {
        if (yinBuffer[tau] < threshold) {
          while (tau + 1 < buffer.length/2 && yinBuffer[tau + 1] < yinBuffer[tau]) {
            tau++;
          }
          break;
        }
      }
      
      // If no pitch found, return 0
      if (tau === buffer.length/2 || yinBuffer[tau] >= threshold) {
        return { frequency: 0, confidence: 0 };
      }
      
      // Quadratic interpolation for better accuracy
      const betterTau = parabolicInterpolation(yinBuffer, tau);
      
      // Calculate frequency and confidence
      const frequency = sampleRate / betterTau;
      const conf = Math.max(0, 1 - yinBuffer[tau]);
      
      return { frequency, confidence: conf };
    }
    
    // Helper function for parabolic interpolation
    function parabolicInterpolation(buffer, tau) {
      if (tau <= 0 || tau >= buffer.length - 1) return tau;
      
      const s0 = buffer[tau - 1];
      const s1 = buffer[tau];
      const s2 = buffer[tau + 1];
      
      return tau + 0.5 * (s0 - s2) / (s0 - 2 * s1 + s2);
    }
    
    // Detect drum type based on frequency and confidence
    function detectDrum(frequency, confidence) {
      if (confidence < 0.4) return 'unknown';
      
      if (frequency >= 30 && frequency <= 100) return 'kick';
      if (frequency > 100 && frequency <= 300) return 'snare';
      if (frequency > 300 && frequency <= 800) return 'tom';
      if (frequency > 800 && frequency <= 3000) return 'hihat';
      if (frequency > 3000) return 'cymbal';
      
      return 'unknown';
    }
    
    // Update harmonic display
    function updateHarmonicDisplay(frequency) {
      if (!frequency || frequency < 20) {
        harmonicFundamental.textContent = '-- Hz';
        harmonicSecond.textContent = '-- Hz';
        harmonicThird.textContent = '-- Hz';
        harmonicFourth.textContent = '-- Hz';
        harmonicFifth.textContent = '-- Hz';
        return;
      }
      
      harmonicFundamental.textContent = `${frequency.toFixed(0)} Hz`;
      harmonicSecond.textContent = `${(frequency * 2).toFixed(0)} Hz`;
      harmonicThird.textContent = `${(frequency * 3).toFixed(0)} Hz`;
      harmonicFourth.textContent = `${(frequency * 4).toFixed(0)} Hz`;
      harmonicFifth.textContent = `${(frequency * 5).toFixed(0)} Hz`;
    }
    
    // Audio processing loop with improved detection
    function processAudio() {
      if (!running) return;

      // Get time domain data
      analyser.getFloatTimeDomainData(dataArray);
      
      // Calculate RMS (root mean square) volume
      let sum = 0;
      for (let i = 0; i < bufferLength; i++) {
        sum += dataArray[i] * dataArray[i];
      }
      const rms = Math.sqrt(sum / bufferLength);
      
      // Update volume history
      volumeHistory[currentIndex] = rms;
      currentIndex = (currentIndex + 1) % volumeHistory.length;
      
      // Update debug display
      currentVolume.textContent = rms.toFixed(4);
      
      // Dynamic noise floor adjustment
      if (noiseSamples < MAX_NOISE_SAMPLES) {
        noiseFloor = (noiseFloor * noiseSamples + rms) / (noiseSamples + 1);
        noiseSamples++;
      }
      
      // Check for drum hit based on VOLUME PEAK
      const now = Date.now();
      const threshold = Math.max(parseFloat(sensitivitySlider.value), noiseFloor * 2);
      
      // Only detect a hit if above threshold and cooldown has passed
      if (rms > threshold && now - lastHitTime > HIT_COOLDOWN) {
        // Create a copy of the buffer for frequency analysis
        const analysisBuffer = new Float32Array(dataArray);
        
        // Detect fundamental frequency
        const { frequency, confidence: conf } = detectFundamental(analysisBuffer, audioCtx.sampleRate);
        
        // Update confidence display
        confidence = conf;
        confidenceEl.textContent = (confidence * 100).toFixed(1) + '%';
        confidenceLevel.style.width = (confidence * 100) + '%';
        
        // Only proceed if we have a valid detection
        if (frequency > 20 && confidence > 0.3) {
          // Detect drum type
          let drumType = detectDrum(frequency, confidence);
          
          // Temporal smoothing using history
          drumHistory.push(drumType);
          if (drumHistory.length > HISTORY_SIZE) {
            drumHistory.shift();
          }
          
          // Get most frequent drum type from history
          const counts = {};
          let maxCount = 0;
          let smoothedType = drumType;
          
          for (const type of drumHistory) {
            counts[type] = (counts[type] || 0) + 1;
            if (counts[type] > maxCount) {
              maxCount = counts[type];
              smoothedType = type;
            }
          }
          
          drumType = smoothedType;
          
          // Update display
          hitCount++;
          hitsEl.textContent = hitCount;
          freqEl.textContent = `${frequency.toFixed(0)} Hz (${drumType.toUpperCase()})`;
          updateHarmonicDisplay(frequency);
          showDrumHit(drumType);
          lastHitTime = now;
          lastFrequency = frequency;
          lastDrumType = drumType;
        }
      }
      
      drawWaveform();
      drawVolumeChart();
      drawSpectrum();
      animationId = requestAnimationFrame(processAudio);
    }
    
    // Start microphone processing
    async function startMic() {
      if (running) return;
      
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // Setup compressor for better dynamics
        const compressor = audioCtx.createDynamicsCompressor();
        compressor.threshold.value = -30;
        compressor.knee.value = 20;
        compressor.ratio.value = 12;
        compressor.attack.value = 0.003;
        compressor.release.value = 0.25;
        
        // Add high-pass filter for better low frequency detection
        const highPassFilter = audioCtx.createBiquadFilter();
        highPassFilter.type = "highpass";
        highPassFilter.frequency.value = 30;
        
        // Get microphone
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        source = audioCtx.createMediaStreamSource(mediaStream);
        
        // Setup analysers
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Float32Array(bufferLength);
        
        analyserSpectrum = audioCtx.createAnalyser();
        analyserSpectrum.fftSize = 256;
        spectrumArray = new Uint8Array(analyserSpectrum.frequencyBinCount);
        
        // Connect nodes
        source.connect(highPassFilter);
        highPassFilter.connect(compressor);
        compressor.connect(analyser);
        compressor.connect(analyserSpectrum);
        
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        
        running = true;
        resetCounter();
        
        startBtn.disabled = true;
        stopBtn.disabled = false;
        
        // Update status
        micStatus.innerHTML = '<span class="status-indicator status-active"></span>Active';
        
        // Initialize canvases
        waveformCanvas.width = waveformCanvas.offsetWidth;
        waveformCanvas.height = waveformCanvas.offsetHeight;
        volumeCanvas.width = volumeCanvas.offsetWidth;
        volumeCanvas.height = volumeCanvas.offsetHeight;
        
        // Show harmonics panel by default
        harmonicContent.classList.add('show');
        harmonicToggle.querySelector('span').textContent = '▲';
        
        processAudio();
      } catch (err) {
        console.error("Audio setup failed:", err);
        alert("Couldn't access microphone. Please check permissions and try again.");
        stopMic();
      }
    }
    
    // Stop microphone processing
    function stopMic() {
      running = false;
      cancelAnimationFrame(animationId);
      
      if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
      if (source) source.disconnect();
      if (analyser) analyser.disconnect();
      if (analyserSpectrum) analyserSpectrum.disconnect();
      if (audioCtx?.state !== 'closed') audioCtx?.close();
      
      startBtn.disabled = false;
      stopBtn.disabled = true;
      
      // Clear canvases
      const waveformCtx = waveformCanvas.getContext('2d');
      waveformCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
      
      const volumeCtx = volumeCanvas.getContext('2d');
      volumeCtx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);
      
      // Update status
      micStatus.innerHTML = '<span class="status-indicator status-inactive"></span>Inactive';
      currentVolume.textContent = '0.00';
      confidenceEl.textContent = '--';
      confidenceLevel.style.width = '0%';
    }
    
    // Reset counter
    function resetCounter() {
      hitCount = 0;
      hitsEl.textContent = hitCount;
      freqEl.textContent = '-- Hz';
      lastDrumEl.textContent = '--';
      drumHistory.length = 0;
      updateHarmonicDisplay(0);
    }
    
    // Update sensitivity
    function updateSensitivity() {
      sensitivityVal.textContent = sensitivitySlider.value;
      thresholdEl.textContent = sensitivitySlider.value;
    }
    
    // Toggle harmonics panel
    function toggleHarmonicsPanel() {
      harmonicContent.classList.toggle('show');
      harmonicToggle.querySelector('span').textContent = 
        harmonicContent.classList.contains('show') ? '▲' : '▼';
    }
    
    // Toggle tool buttons
    function toggleTool(btn) {
      btn.classList.toggle('active');
    }
    
    // Initialize on load
    window.addEventListener('load', () => {
      waveformCanvas.width = waveformCanvas.offsetWidth;
      waveformCanvas.height = waveformCanvas.offsetHeight;
      
      volumeCanvas.width = volumeCanvas.offsetWidth;
      volumeCanvas.height = volumeCanvas.offsetHeight;
      
      // Add tooltips to drum pads
      drumPads.forEach(pad => {
        pad.title = `Detects ${pad.dataset.type} drums (${getDrumProfile(pad.dataset.type).range[0]}-${getDrumProfile(pad.dataset.type).range[1]} Hz)`;
      });
    });
    
    window.addEventListener('resize', () => {
      if (running) {
        waveformCanvas.width = waveformCanvas.offsetWidth;
        waveformCanvas.height = waveformCanvas.offsetHeight;
        
        volumeCanvas.width = volumeCanvas.offsetWidth;
        volumeCanvas.height = volumeCanvas.offsetHeight;
      }
    });
    
    window.addEventListener('beforeunload', stopMic);
  </script>
</body>
</html>