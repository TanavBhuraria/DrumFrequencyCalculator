<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Drum ID — Centroid-based (1=snare,2=toms,3=kick)</title>
<style>
  body{background:#071029;color:#fff;font-family:Inter,Segoe UI,Arial,sans-serif;display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;margin:0;padding:18px;text-align:center}
  h1{color:#f59e0b;margin-bottom:8px}
  button{background:#06b6d4;border:none;padding:10px 18px;border-radius:8px;color:#022;cursor:pointer;font-weight:700;margin-bottom:12px}
  .result{font-size:2rem;font-weight:800;color:#f59e0b;margin:8px 0;min-height:44px}
  .sub{color:#94a3b8;margin-bottom:6px}
  .debug{font-family:monospace;font-size:0.85rem;color:#cbd5e1;margin-top:12px;white-space:pre-wrap;max-width:820px;text-align:left}
</style>
</head>
<body>
  <h1>Drum ID — Centroid-based</h1>
  <button id="btn">Start</button>
  <div class="sub">Outputs: <strong>1 = snare</strong>, <strong>2 = toms</strong>, <strong>3 = kick</strong> (shows idle when quiet)</div>
  <div class="result" id="label">idle</div>
  <div class="debug" id="dbg">debug: not running</div>

<script>
/*
Centroid-based Drum Identifier
1 -> snare
2 -> toms
3 -> kick

Principles:
- Hit detection: adaptive noise floor (EMA) + peak detection to avoid missing loud low hits.
- Spectral centroid computed from analyser.getByteFrequencyData (0..255).
- centroid (Hz) used as primary differentiator; augmented with band energy ratios.
- Classification is volume-invariant (ratios, centroid) once a hit is detected.
- Idle shown if no hits detected for a short window.
- Conservative smoothing via short history majority.
*/

document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('btn');
  const labelEl = document.getElementById('label');
  const dbg = document.getElementById('dbg');

  let audioCtx = null, analyser = null, src = null, script = null;
  let running = false;

  // === PARAMETERS (tweak if needed) ===
  const FFT_SIZE = 16384;         // high-enough resolution for centroid
  const PROCESSOR_FRAMES = 2048;  // scriptProcessor frame
  const NOISE_EMA_ALPHA = 0.02;   // adapt speed for noise floor
  const MIN_MEANABS = 0.0002;     // absolute minimum mean abs to consider
  const HIT_MULT = 1.8;           // multiplier of noiseFloor for meanAbs trigger
  const PEAK_ABS_MIN = 0.04;      // absolute peak threshold to catch sharp transients
  const PEAK_MULT = 4.0;          // peak relative to noise floor
  const HIT_DEBOUNCE_MS = 80;     // minimum ms between hits
  const HOLD_MS = 360;            // show detected label for this long
  const HISTORY_LEN = 5;          // smoothing history length

  // centroid bands for classification (Hz)
  // tuned to be conservative and generalize
  const CENTROID_SNARE_MIN = 350; // >= this tends to snare/noise
  const CENTROID_TOM_MIN = 140;   // >= this is tom range lower bound
  const CENTROID_KICK_MAX = 160;  // <= this tends to kick

  // energy band ranges (Hz) used for ratios
  const LOW_BAND = [20, 160];
  const MID_BAND = [160, 900];
  const HIGH_BAND = [900, 8000];

  // === STATE ===
  let sampleRate = 44100;
  let noiseEMA = 0.002;   // adaptive ambient
  let lastHitTime = 0;
  let lastShownTime = 0;
  let lastLabel = null;
  const history = [];

  // start / stop
  btn.addEventListener('click', async () => {
    if (running) { stop(); btn.textContent='Start'; labelEl.textContent='idle'; dbg.textContent='stopped'; }
    else { await start(); btn.textContent='Stop'; }
  });

  async function start() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sampleRate = audioCtx.sampleRate || 44100;

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = Math.min(FFT_SIZE, 32768);
    analyser.smoothingTimeConstant = 0.0;

    script = audioCtx.createScriptProcessor(PROCESSOR_FRAMES, 1, 1);
    script.onaudioprocess = onAudioProcess;

    const stream = await navigator.mediaDevices.getUserMedia({
      audio: { channelCount: 1, echoCancellation: false, noiseSuppression: false, autoGainControl: false }
    });

    src = audioCtx.createMediaStreamSource(stream);
    src.connect(analyser);
    src.connect(script);
    script.connect(audioCtx.destination);

    running = true;
    dbg.textContent = `running — sr:${sampleRate} fft:${analyser.fftSize}`;
  }

  function stop() {
    try { src.mediaStream.getTracks().forEach(t => t.stop()); } catch(e){}
    try { script.disconnect(); analyser.disconnect(); audioCtx.close(); } catch(e){}
    running = false;
    history.length = 0;
    lastLabel = null;
  }

  function onAudioProcess(ev) {
    if (!analyser) return;

    // Use inputBuffer for gating (accurate and low-latency)
    const input = ev.inputBuffer.getChannelData(0);
    let sumAbs = 0, peak = 0;
    for (let i=0;i<input.length;i++) {
      const a = Math.abs(input[i]);
      sumAbs += a;
      if (a > peak) peak = a;
    }
    const meanAbs = sumAbs / input.length;

    // update noise floor (EMA)
    noiseEMA = noiseEMA * (1 - NOISE_EMA_ALPHA) + meanAbs * NOISE_EMA_ALPHA;
    const meanThreshold = Math.max(MIN_MEANABS, noiseEMA * HIT_MULT);
    const peakThreshold = Math.max(PEAK_ABS_MIN, noiseEMA * PEAK_MULT);

    const now = performance.now();

    // Hit detection — dual condition: meanAbs or peak
    const isHit = (meanAbs >= meanThreshold) || (peak >= peakThreshold);
    if (isHit && (now - lastHitTime) > HIT_DEBOUNCE_MS) {
      lastHitTime = now;
      analyzeSpectrumAndClassify();
    } else {
      // clear to idle if nothing for HOLD_MS
      if (lastShownTime && (now - lastShownTime) > HOLD_MS) {
        labelEl.textContent = 'idle';
        lastLabel = null;
      }
    }

    // update debug minimal info
    dbg.textContent = `meanAbs:${meanAbs.toFixed(4)} peak:${peak.toFixed(3)} noise:${noiseEMA.toFixed(4)} thr:${meanThreshold.toFixed(4)}`;
  }

  function analyzeSpectrumAndClassify() {
    // Spectrum snapshot (bytes 0..255)
    const freqLen = analyser.frequencyBinCount;
    const freqBytes = new Uint8Array(freqLen);
    analyser.getByteFrequencyData(freqBytes);

    const binSize = sampleRate / analyser.fftSize;
    // compute centroid (Hz) and band energies
    let sumMag = 0;
    let weighted = 0;
    let E_low = 0, E_mid = 0, E_high = 0;
    let maxMag = 0, maxBin = 0;
    for (let i=1;i<freqLen;i++) {
      const mag = freqBytes[i];
      const f = i * binSize;
      sumMag += mag;
      weighted += mag * f;
      if (mag > maxMag) { maxMag = mag; maxBin = i; }
      if (f >= LOW_BAND[0] && f <= LOW_BAND[1]) E_low += mag;
      else if (f > MID_BAND[0] && f <= MID_BAND[1]) E_mid += mag;
      else if (f > HIGH_BAND[0] && f <= HIGH_BAND[1]) E_high += mag;
    }
    const centroid = sumMag > 0 ? (weighted / sumMag) : 0;
    const peakFreq = maxBin * binSize;
    const eTotal = Math.max(1, E_low + E_mid + E_high);
    const lowR = E_low / eTotal, midR = E_mid / eTotal, highR = E_high / eTotal;

    // Classification rules (centroid primary, ratios as tie-breakers)
    // Conservative thresholds chosen for general kits; we always produce 1/2/3 on hit.
    let chosenId;

    // If centroid very low and lowR dominant -> Kick
    if (centroid <= CENTROID_KICK_MAX && lowR > 0.45) {
      chosenId = 3; // kick
    }
    // If centroid in tom band and mid ratio moderately high -> tom
    else if (centroid >= CENTROID_TOM_MIN && centroid < CENTROID_SNARE_MIN && midR >= 0.30) {
      chosenId = 2; // toms
    }
    // If centroid high OR high ratio dominant -> snare
    else if (centroid >= CENTROID_SNARE_MIN || highR > 0.45 || (midR + highR) > 0.6) {
      chosenId = 1; // snare
    }
    // Edge handling: if centroid near low but lowR not dominant, use ratio tie-breaker
    else {
      // decide by highest relative band ratio
      const maxR = Math.max(lowR, midR, highR);
      if (maxR === lowR) chosenId = 3;
      else if (maxR === midR) chosenId = 2;
      else chosenId = 1;
    }

    // smoothing: history majority to avoid single-frame flips
    history.push(chosenId);
    if (history.length > HISTORY_LEN) history.shift();
    const counts = history.reduce((acc, v) => { acc[v] = (acc[v]||0)+1; return acc; }, {});
    // pick majority if exists
    let final = chosenId;
    for (const k of [1,2,3]) {
      if (counts[k] && counts[k] > Math.floor(HISTORY_LEN/2)) { final = k; break; }
    }

    // update UI
    const labelText = final === 1 ? '1 (snare)' : final === 2 ? '2 (toms)' : '3 (kick)';
    labelEl.textContent = labelText;
    lastLabel = final;
    lastShownTime = performance.now();

    // debug details for tuning
    dbg.textContent = [
      `centroid:${Math.round(centroid)}Hz peak:${Math.round(peakFreq)}Hz`,
      `ratios low/mid/high: ${lowR.toFixed(2)} / ${midR.toFixed(2)} / ${highR.toFixed(2)}`,
      `maxMag:${maxMag.toFixed(1)} chosen:${chosenId} final:${final}`
    ].join('\n');
  }

}); // dom loaded
</script>
</body>
</html>
