<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Drum Analysis — Stable + Pitch</title>
  <style>
    body {
      background: #000; color: #fff; font-family: Inter, system-ui, sans-serif;
      margin: 0; padding: 2rem; text-align: center;
    }
    h1 { margin: 0 0 1rem 0; font-size: 1.6rem; }
    button {
      font-size: 1rem; padding: 0.8rem 1.2rem; margin: 0.5rem;
      border-radius: 8px; border: none; background:#333; color:#fff; cursor:pointer;
    }
    button:disabled { background:#222; color:#666; cursor:not-allowed; }
    #controls { margin-top: 1rem; }
    #info { margin-top: 1.2rem; font-size: 1.1rem; }
    #freq { font-size: 1.4rem; margin-top: .6rem; }
    #hits { font-size: 1.4rem; margin-top: .2rem; }
    .flash { background: #fff; color:#000; padding: .15rem .3rem; border-radius:6px; }
    .row { display:flex; gap:0.5rem; justify-content:center; align-items:center; margin-top:0.8rem; }
    input[type=range] { width:200px; }
    small { color:#bbb; display:block; margin-top:.25rem; }
  </style>
</head>
<body>
  <h1>Live Drum Analysis — Stable + Pitch</h1>

  <div id="controls">
    <button id="start-btn">Start Microphone</button>
    <button id="stop-btn" disabled>Stop Microphone</button>
  </div>

  <div id="info">
    <div id="freq">Frequency: -- Hz</div>
    <div id="hits">Hits Detected: 0</div>

    <div class="row" style="margin-top:12px;">
      <label style="display:flex;flex-direction:column;align-items:center;">
        Threshold
        <input id="threshold-slider" type="range" min="0.005" max="0.08" step="0.005" value="0.03">
        <small id="threshold-val">0.030</small>
      </label>
      <label style="display:flex;flex-direction:column;align-items:center;margin-left:12px;">
        Pitch smoothing (frames)
        <input id="pitch-smooth" type="range" min="1" max="10" step="1" value="3">
        <small id="pitch-smooth-val">3</small>
      </label>
    </div>
  </div>

  <script>
  // Stable mic + hits + pitch combined

  const startBtn = document.getElementById('start-btn');
  const stopBtn = document.getElementById('stop-btn');
  const freqEl = document.getElementById('freq');
  const hitsEl = document.getElementById('hits');
  const thresholdSlider = document.getElementById('threshold-slider');
  const thresholdVal = document.getElementById('threshold-val');
  const pitchSmoothSlider = document.getElementById('pitch-smooth');
  const pitchSmoothVal = document.getElementById('pitch-smooth-val');

  let audioCtx = null;
  let analyser = null;
  let source = null;
  let mediaStream = null;
  let dataArray = null;
  let bufferLength = 0;
  let running = false;
  let animationId = null;

  let hitCount = 0;
  let hitReady = true;
  let lastHitTime = 0;

  // pitch smoothing ring buffer
  const pitchHistory = [];
  let pitchHistorySize = Number(pitchSmoothSlider.value);

  // pitch detection bounds (Hz)
  const minFreq = 30;   // won't accept <30Hz
  const maxFreq = 5000; // won't accept >5000Hz

  thresholdVal.textContent = Number(thresholdSlider.value).toFixed(3);
  pitchSmoothVal.textContent = pitchSmoothSlider.value;

  thresholdSlider.addEventListener('input', () => {
    thresholdVal.textContent = Number(thresholdSlider.value).toFixed(3);
  });
  pitchSmoothSlider.addEventListener('input', () => {
    pitchSmoothVal.textContent = pitchSmoothSlider.value;
    pitchHistorySize = Number(pitchSmoothSlider.value);
    // trim history
    while (pitchHistory.length > pitchHistorySize) pitchHistory.shift();
  });

  // Robust autocorrelation limited by expected freq range and buffer size
  function autoCorrelate(buf, sampleRate) {
    const SIZE = buf.length;
    if (SIZE < 16) return -1;

    // RMS energy check
    let rms = 0;
    for (let i=0;i<SIZE;i++) rms += buf[i]*buf[i];
    rms = Math.sqrt(rms / SIZE);
    if (rms < 0.005) return -1; // too quiet

    // compute min/max lag from freq bounds
    const maxLag = Math.min(SIZE - 2, Math.floor(sampleRate / Math.max(minFreq,1)));
    const minLag = Math.max(2, Math.floor(sampleRate / Math.min(maxFreq, sampleRate)));

    if (minLag >= maxLag) return -1;

    let bestCorr = -Infinity;
    let bestLag = -1;

    // quick mean subtraction to reduce DC
    let mean = 0;
    for (let i=0;i<SIZE;i++) mean += buf[i];
    mean /= SIZE;
    // compute normalized autocorrelation over lag range
    for (let lag = minLag; lag <= maxLag; lag++) {
      let corr = 0;
      for (let i=0;i<SIZE - lag; i++) {
        corr += (buf[i] - mean) * (buf[i + lag] - mean);
      }
      if (corr > bestCorr) {
        bestCorr = corr;
        bestLag = lag;
      }
    }

    if (bestLag <= 0) return -1;

    const frequency = sampleRate / bestLag;
    if (!isFinite(frequency) || frequency < minFreq || frequency > maxFreq) return -1;
    return frequency;
  }

  function detectHit(rms) {
    const threshold = Number(thresholdSlider.value);
    const now = Date.now();
    // require short cooldown to avoid double counting
    const cooldown = 120; // ms
    if (rms > threshold && hitReady && (now - lastHitTime > cooldown)) {
      hitCount++;
      hitsEl.textContent = `Hits Detected: ${hitCount}`;
      // quick body flash (visual)
      document.body.classList.add('flash');
      setTimeout(()=>document.body.classList.remove('flash'), 80);
      hitReady = false;
      lastHitTime = now;
      setTimeout(()=> { hitReady = true; }, cooldown);
    }
  }

  async function startMic() {
    if (running) return;
    // clean previous objects if any
    stopMic(); // ensure clean state (will return quickly if nothing active)

    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (e) {
      alert('Microphone access denied or unavailable.');
      return;
    }

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // ensure resumed (some browsers start suspended)
    if (audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch(e){ /* ignore */ }
    }

    source = audioCtx.createMediaStreamSource(mediaStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024; // reasonable compromise
    bufferLength = analyser.fftSize;
    dataArray = new Float32Array(bufferLength);
    source.connect(analyser);

    running = true;
    hitCount = 0;
    hitsEl.textContent = `Hits Detected: ${hitCount}`;
    freqEl.textContent = 'Frequency: -- Hz';
    pitchHistory.length = 0;

    startBtn.disabled = true;
    stopBtn.disabled = false;

    // limit expensive pitch checks to every N frames
    let frameCount = 0;
    const pitchEveryNFrames = 3; // run pitch every 3 animation frames (tweakable)

    function loop() {
      if (!running) return;
      analyser.getFloatTimeDomainData(dataArray);

      // RMS amplitude
      let sum = 0;
      for (let i=0;i<bufferLength;i++) sum += dataArray[i]*dataArray[i];
      const rms = Math.sqrt(sum / bufferLength);

      // hit detection
      detectHit(rms);

      // pitch detection less frequent for perf
      if ((frameCount++ % pitchEveryNFrames) === 0) {
        const pitch = autoCorrelate(dataArray, audioCtx.sampleRate);
        if (pitch > 0 && isFinite(pitch)) {
          // smoothing history
          pitchHistory.push(pitch);
          if (pitchHistory.length > pitchHistorySize) pitchHistory.shift();
          // compute mean
          const avg = pitchHistory.reduce((s,v)=>s+v,0)/pitchHistory.length;
          freqEl.textContent = `Frequency: ${avg.toFixed(2)} Hz`;
        } else {
          // if no valid pitch, show placeholder
          freqEl.textContent = 'Frequency: -- Hz';
        }
      }

      animationId = requestAnimationFrame(loop);
    }
    loop();
    running = true;
  }

  function stopMic() {
    // cancel animation
    if (typeof animationId !== 'undefined' && animationId !== null) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }
    running = false;

    // stop all tracks
    if (mediaStream) {
      try {
        mediaStream.getTracks().forEach(t => t.stop());
      } catch(e){}
      mediaStream = null;
    }
    // disconnect nodes
    if (source) {
      try { source.disconnect(); } catch(e){}
      source = null;
    }
    if (analyser) {
      try { analyser.disconnect(); } catch(e){}
      analyser = null;
    }
    // close audio context
    if (audioCtx) {
      try { audioCtx.close(); } catch(e){}
      audioCtx = null;
    }

    startBtn.disabled = false;
    stopBtn.disabled = true;
    freqEl.textContent = 'Frequency: -- Hz';
    hitsEl.textContent = `Hits Detected: ${hitCount}`;
  }

  startBtn.addEventListener('click', startMic);
  stopBtn.addEventListener('click', stopMic);

  // ensure clean when user navigates away
  window.addEventListener('beforeunload', stopMic);
  </script>
</body>
</html>
