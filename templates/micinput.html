<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Drum Classifier — Fixed Idle + No Unknown</title>
<style>
  body{background:#071029;color:#fff;font-family:Segoe UI,system-ui,Arial,sans-serif;display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;margin:0;padding:18px;text-align:center}
  h1{color:#f59e0b;margin-bottom:8px}
  button{background:#06b6d4;border:none;padding:12px 22px;border-radius:10px;color:#012;cursor:pointer;font-weight:700;margin-bottom:12px}
  .result{font-size:2.2rem;font-weight:800;color:#f59e0b;margin:8px 0;min-height:48px}
  .sub{color:#94a3b8;margin-bottom:6px}
  .debug{font-family:monospace;font-size:0.86rem;color:#cbd5e1;margin-top:12px;white-space:pre-wrap;text-align:left;max-width:800px}
</style>
</head>
<body>
  <h1>Drum Classifier — 1:Snare, 2:Toms, 3:Kick</h1>
  <button id="btn">Start</button>
  <div class="sub">Always returns 1/2/3. Idle when nothing is played.</div>
  <div class="result" id="label">idle</div>
  <div class="debug" id="dbg">debug: not running</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('btn');
  const labelEl = document.getElementById('label');
  const dbg = document.getElementById('dbg');

  let audioCtx = null, analyser = null, src = null, script = null;
  let isRunning = false;

  // PARAMETERS
  const FFT_SIZE = 16384;   // decent low-freq resolution but not insane
  const PROCESSOR = 2048;
  const SR_DEFAULT = 44100;

  // Gating & thresholds (tuned conservative defaults)
  let noiseEMA = 0.0018;    // adaptive noise floor
  const EMA_ALPHA = 0.02;   // noise adaptation speed
  const MIN_MEANABS = 0.0003; // floor
  const HIT_MULT = 1.7;     // meanAbs multiplier for trigger
  const PEAK_ABS_MIN = 0.04; // absolute peak threshold (for strong transient)
  const PEAK_MULT = 4.0;    // peak relative to noise floor multiplier

  // smoothing and debounce
  const HIT_DEBOUNCE_MS = 80;
  let lastHit = 0;
  const HISTORY = 5;
  const classBuffer = [];

  // audio state
  let sampleRate = SR_DEFAULT;

  btn.addEventListener('click', async () => {
    if (isRunning) { stop(); btn.textContent='Start'; labelEl.textContent='idle'; dbg.textContent='stopped'; }
    else { await start(); btn.textContent='Stop'; }
  });

  async function start() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sampleRate = audioCtx.sampleRate || SR_DEFAULT;
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = Math.min(FFT_SIZE, 32768);
    analyser.smoothingTimeConstant = 0.0;

    script = audioCtx.createScriptProcessor(PROCESSOR, 1, 1);
    script.onaudioprocess = onAudioProcess;

    const stream = await navigator.mediaDevices.getUserMedia({ audio: { channelCount:1, echoCancellation:false, noiseSuppression:false, autoGainControl:false }});
    src = audioCtx.createMediaStreamSource(stream);
    src.connect(analyser);
    src.connect(script);
    script.connect(audioCtx.destination);

    isRunning = true;
    dbg.textContent = `running — sr:${sampleRate} fft:${analyser.fftSize}`;
  }

  function stop() {
    try { src.mediaStream.getTracks().forEach(t => t.stop()); } catch(e){}
    try { script.disconnect(); analyser.disconnect(); audioCtx.close(); } catch(e){}
    audioCtx = analyser = src = script = null;
    isRunning = false;
    classBuffer.length = 0;
  }

  function onAudioProcess(ev) {
    if (!analyser) return;
    const bufferLen = analyser.fftSize;

    // USE time-domain bytes for gating (works across browsers)
    const timeBytes = new Uint8Array(Math.min(2048, bufferLen)); // small read for low-latency gating
    analyser.getByteTimeDomainData(timeBytes);

    // compute mean absolute and peak absolute in this small frame
    let sumAbs = 0;
    let peakAbs = 0;
    for (let i=0;i<timeBytes.length;i++) {
      const v = (timeBytes[i] - 128) / 128;
      const av = Math.abs(v);
      sumAbs += av;
      if (av > peakAbs) peakAbs = av;
    }
    const meanAbs = sumAbs / timeBytes.length;

    // update noise floor EMA
    noiseEMA = noiseEMA * (1 - EMA_ALPHA) + meanAbs * EMA_ALPHA;
    const triggerThreshold = Math.max(MIN_MEANABS, noiseEMA * HIT_MULT);
    const peakThreshold = Math.max(PEAK_ABS_MIN, noiseEMA * PEAK_MULT);

    const now = performance.now();

    // HIT CRITERIA (dual trigger):
    // A hit is true if meanAbs exceeds trigger OR peakAbs exceeds peakThreshold
    if ((meanAbs >= triggerThreshold || peakAbs >= peakThreshold) && (now - lastHit) > HIT_DEBOUNCE_MS) {
      lastHit = now;
      classifyHit(); // capture spectrum and classify
    } else {
      // If no hit recently, clear to idle after short hold
      if (lastHit && (now - lastHit) > 600) labelEl.textContent = 'idle';
    }

    // debug info update (not verbose)
    dbg.textContent = `meanAbs:${meanAbs.toFixed(4)} peak:${peakAbs.toFixed(3)} thr:${triggerThreshold.toFixed(4)} pthr:${peakThreshold.toFixed(3)} noise:${noiseEMA.toFixed(4)}`;
  }

  function classifyHit() {
    if (!analyser) return;

    // Get spectrum snapshot
    const freqLen = analyser.frequencyBinCount;
    const freqBytes = new Uint8Array(freqLen);
    analyser.getByteFrequencyData(freqBytes); // 0..255

    // basic spectral features
    const binSize = sampleRate / analyser.fftSize;

    // define bands - make them broader so classification is robust
    const lowBand = [20, 160];    // kick/floor area
    const midBand = [160, 900];   // toms/snare area
    const highBand = [900, 8000]; // cymbals etc.

    let E_low = 0, E_mid = 0, E_high = 0, E_full = 0;
    let maxMag = 0, maxBin = 0;
    let weightedFreq = 0, sumMag = 0;
    for (let i = 1; i < freqLen; i++) {
      const f = i * binSize;
      const m = freqBytes[i];
      E_full += m;
      sumMag += m;
      weightedFreq += m * f;
      if (m > maxMag) { maxMag = m; maxBin = i; }
      if (f >= lowBand[0] && f <= lowBand[1]) E_low += m;
      else if (f > midBand[0] && f <= midBand[1]) E_mid += m;
      else if (f > highBand[0] && f <= highBand[1]) E_high += m;
    }
    const centroid = sumMag > 0 ? (weightedFreq / sumMag) : 0;
    const peakFreq = maxBin * binSize;

    // normalize
    const eFull = Math.max(1, E_full);
    const lowRatio = E_low / eFull;
    const midRatio = E_mid / eFull;
    const highRatio = E_high / eFull;

    // quick flatness indicator (rough)
    let logSum = 0, nonzero = 0;
    for (let i=1;i<freqLen;i++){ const v = Math.max(1, freqBytes[i]); logSum += Math.log(v); nonzero++; }
    const geoMean = Math.exp(logSum / Math.max(1, nonzero));
    const arithMean = sumMag / Math.max(1, freqLen-1);
    const flatness = arithMean > 0 ? (geoMean / arithMean) : 0;

    // Classification logic (conservative + expanded ranges)
    // Score heuristics (values tuned to be robust and non-overlapping)
    let kickScore = 0, tomScore = 0, snareScore = 0;

    // Kick: strong low band, centroid low, peak low
    if (lowRatio > 0.35) kickScore += 2;
    if (centroid < 180) kickScore += 1;
    if (peakFreq < 180) kickScore += 1;

    // Tom: mid energy strong and tonal (peak in mid)
    if (midRatio > 0.30) tomScore += 2;
    if (peakFreq >= 90 && peakFreq <= 700) tomScore += 1;
    if (flatness < 0.6 && midRatio > 0.18) tomScore += 1;

    // Snare: broadband mid+high and higher centroid
    if ((midRatio + highRatio) > 0.5) snareScore += 2;
    if (centroid > 350) snareScore += 1;
    if (flatness > 0.4) snareScore += 1;

    // Soft tie-breakers to avoid mislabels:
    // If one score strongly dominates, pick it. Otherwise prefer snare (id=1) as fallback per your request.
    const scores = [{id:3,score:kickScore},{id:2,score:tomScore},{id:1,score:snareScore}];
    scores.sort((a,b)=>b.score - a.score);

    let chosenId;
    // require at least 2 points to be confident for non-snare; snare allowed as default
    if (scores[0].score >= 2 && scores[0].score >= scores[1].score + 1) {
      chosenId = scores[0].id;
    } else {
      // fallback: choose snare (1) to satisfy "call highest drum we have"
      chosenId = 1;
    }

    // smoothing / majority history
    classBuffer.push(chosenId);
    if (classBuffer.length > HISTORY) classBuffer.shift();
    const counts = classBuffer.reduce((acc, v) => { acc[v] = (acc[v]||0)+1; return acc; }, {});
    // majority
    let final = null;
    for (const k of [1,2,3]) {
      if (counts[k] && counts[k] > Math.floor(HISTORY/2)) { final = Number(k); break; }
    }
    if (final === null) final = chosenId;

    // Update UI
    const idText = final === 1 ? '1 (snare)' : final === 2 ? '2 (toms)' : '3 (kick)';
    labelEl.textContent = idText;
    dbg.textContent = [
      `ratios low/mid/high: ${lowRatio.toFixed(2)}/${midRatio.toFixed(2)}/${highRatio.toFixed(2)}`,
      `centroid: ${centroid.toFixed(1)}Hz peak:${peakFreq.toFixed(1)}Hz maxMag:${maxMag.toFixed(1)}`,
      `scores: kick=${kickScore} tom=${tomScore} snare=${snareScore}`,
      `chosen:${chosenId} final:${final}`
    ].join('\n');
  }

});
</script>
</body>
</html>
