<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Professional Drum Analysis</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 800px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      width: 100%;
    }
    
    h1 {
      font-size: 2.8rem;
      margin-bottom: 10px;
      background: linear-gradient(90deg, #ff7e5f, #feb47b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .subtitle {
      font-size: 1.2rem;
      color: #a0a0d0;
      max-width: 600px;
      margin: 0 auto;
    }
    
    .visualization {
      width: 100%;
      height: 200px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      margin-bottom: 30px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .drum-display {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      gap: 10px;
      padding: 20px;
    }
    
    .drum-pad {
      width: 70px;
      height: 70px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2rem;
      font-weight: bold;
      color: rgba(255, 255, 255, 0.7);
      transition: all 0.1s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    
    .drum-pad.active {
      transform: scale(1.2);
      background: rgba(255, 126, 95, 0.8);
      box-shadow: 0 0 20px rgba(255, 126, 95, 0.7);
    }
    
    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    button {
      background: linear-gradient(135deg, #ff7e5f, #feb47b);
      color: white;
      border: none;
      padding: 14px 28px;
      font-size: 1.1rem;
      font-weight: 600;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 126, 95, 0.4);
      min-width: 180px;
    }
    
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(255, 126, 95, 0.6);
    }
    
    button:disabled {
      background: #555;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      width: 100%;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 25px;
      text-align: center;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .stat-card h2 {
      font-size: 1.3rem;
      margin-bottom: 15px;
      color: #a0a0d0;
    }
    
    .stat-value {
      font-size: 3.5rem;
      font-weight: 700;
      background: linear-gradient(90deg, #ff7e5f, #feb47b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .settings {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 25px;
      width: 100%;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .slider-container {
      margin-bottom: 20px;
    }
    
    .slider-container label {
      display: block;
      margin-bottom: 10px;
      font-size: 1.1rem;
      color: #a0a0d0;
      display: flex;
      justify-content: space-between;
    }
    
    .slider-container span {
      font-weight: bold;
      color: #ff7e5f;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ff7e5f;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(255, 126, 95, 0.7);
    }
    
    .canvas-container {
      width: 100%;
      height: 150px;
      margin-top: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }
    
    canvas {
      width: 100%;
      height: 100%;
    }
    
    .hit-indicator {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .hit-indicator.active {
      opacity: 1;
    }
    
    .waveform {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 60px;
    }
    
    footer {
      margin-top: 40px;
      text-align: center;
      color: #777;
      font-size: 0.9rem;
      padding: 20px;
    }
    
    @media (max-width: 600px) {
      h1 {
        font-size: 2.2rem;
      }
      
      .stat-value {
        font-size: 2.8rem;
      }
      
      .drum-pad {
        width: 50px;
        height: 50px;
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Professional Drum Analyzer</h1>
      <p class="subtitle">Real-time drum detection with enhanced low-frequency analysis</p>
    </header>
    
    <div class="visualization">
      <div class="drum-display">
        <div class="drum-pad" data-type="kick">KICK</div>
        <div class="drum-pad" data-type="snare">SNARE</div>
        <div class="drum-pad" data-type="hihat">HI-HAT</div>
        <div class="drum-pad" data-type="tom">TOM</div>
        <div class="drum-pad" data-type="cymbal">CYMBAL</div>
      </div>
    </div>
    
    <div class="controls">
      <button id="start-btn">Start Microphone</button>
      <button id="stop-btn" disabled>Stop Microphone</button>
      <button id="reset-btn">Reset Counter</button>
    </div>
    
    <div class="stats">
      <div class="stat-card">
        <h2>Hits Detected</h2>
        <div id="hits" class="stat-value">0</div>
      </div>
      
      <div class="stat-card">
        <h2>Current Frequency</h2>
        <div id="frequency" class="stat-value">-- Hz</div>
      </div>
      
      <div class="stat-card">
        <h2>Volume Level</h2>
        <div id="volume" class="stat-value">-- dB</div>
      </div>
    </div>
    
    <div class="settings">
      <div class="slider-container">
        <label>
          Sensitivity
          <span id="sensitivity-val">0.03</span>
        </label>
        <input type="range" id="sensitivity-slider" min="0.005" max="0.08" step="0.005" value="0.03">
      </div>
      
      <div class="slider-container">
        <label>
          Low-Pass Filter
          <span id="lowpass-val">180 Hz</span>
        </label>
        <input type="range" id="lowpass-slider" min="40" max="300" step="10" value="180">
      </div>
      
      <div class="slider-container">
        <label>
          Drum Type Sensitivity
          <span id="drum-sensitivity-val">Medium</span>
        </label>
        <input type="range" id="drum-sensitivity-slider" min="1" max="3" step="1" value="2">
      </div>
      
      <div class="canvas-container">
        <canvas id="waveform"></canvas>
      </div>
    </div>
  </div>
  
  <div class="hit-indicator" id="hit-indicator"></div>
  
  <footer>
    <p>Professional Drum Analysis Tool | Enhanced Low-Frequency Detection</p>
  </footer>

  <script>
  // DOM Elements
  const startBtn = document.getElementById('start-btn');
  const stopBtn = document.getElementById('stop-btn');
  const resetBtn = document.getElementById('reset-btn');
  const hitsEl = document.getElementById('hits');
  const freqEl = document.getElementById('frequency');
  const volumeEl = document.getElementById('volume');
  const sensitivitySlider = document.getElementById('sensitivity-slider');
  const sensitivityVal = document.getElementById('sensitivity-val');
  const hitIndicator = document.getElementById('hit-indicator');
  const waveformCanvas = document.getElementById('waveform');
  const ctx = waveformCanvas.getContext('2d');
  const drumPads = document.querySelectorAll('.drum-pad');

  // Audio variables
  let audioCtx = null;
  let analyser = null;
  let source = null;
  let mediaStream = null;
  let dataArray = null;
  let animationId = null;
  
  // State variables
  let running = false;
  let hitCount = 0;
  let lastDrumType = null;
  let hitCooldown = false;
  let lastHitTime = 0;

  // Drum frequency profiles (optimized for fast response)
  const drumProfiles = {
    kick: {
      range: [30, 100],
      color: '#ff5e5e',
      decay: 150,  // Faster visual reset
      threshold: 0.02
    },
    snare: {
      range: [150, 300],
      color: '#5effae',
      decay: 120,
      threshold: 0.015
    },
    hihat: {
      range: [4000, 8000],
      color: '#5eb3ff',
      decay: 80,
      threshold: 0.01
    },
    tom: {
      range: [80, 200],
      color: '#ffbe5e',
      decay: 100,
      threshold: 0.018
    },
    cymbal: {
      range: [3000, 10000],
      color: '#d85eff',
      decay: 60,
      threshold: 0.008
    }
  };

  // Initialize UI
  sensitivityVal.textContent = sensitivitySlider.value;

  // Event listeners (UNCHANGED - already perfect)
  startBtn.addEventListener('click', startMic);
  stopBtn.addEventListener('click', stopMic);
  resetBtn.addEventListener('click', () => {
    hitCount = 0;
    hitsEl.textContent = hitCount;
  });
  sensitivitySlider.addEventListener('input', () => {
    sensitivityVal.textContent = sensitivitySlider.value;
  });

  // Visual feedback (MODIFIED for faster reset)
  function showDrumHit(drumType) {
    const profile = drumProfiles[drumType];
    
    // Pad animation
    drumPads.forEach(pad => {
      if (pad.dataset.type === drumType) {
        pad.style.backgroundColor = profile.color;
        pad.style.boxShadow = `0 0 20px ${profile.color}`;
        setTimeout(() => {
          pad.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
          pad.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.3)';
        }, profile.decay);
      }
    });
    
    // Screen flash
    hitIndicator.style.background = `radial-gradient(circle, ${profile.color}77 0%, transparent 70%)`;
    hitIndicator.classList.add('active');
    setTimeout(() => hitIndicator.classList.remove('active'), profile.decay);
  }

  // Draw waveform (UNCHANGED - works perfectly)
  function drawWaveform() {
    if (!analyser || !running) return;
    
    analyser.getFloatTimeDomainData(dataArray);
    
    ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#ff7e5f';
    
    const sliceWidth = waveformCanvas.width / bufferLength;
    let x = 0;
    
    for (let i = 0; i < bufferLength; i++) {
      const y = waveformCanvas.height/2 + (dataArray[i] * waveformCanvas.height/2);
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      x += sliceWidth;
    }
    
    ctx.stroke();
  }

  // NEW: Ultra-responsive drum detection
  function detectDrum(fftData, sampleRate) {
    if (hitCooldown) return null;
    
    const fftSize = fftData.length;
    const binSize = sampleRate / analyser.fftSize;
    const now = Date.now();
    
    // Require minimum 50ms between hits
    if (now - lastHitTime < 50) return null;
    
    // Calculate energy in each drum's frequency range
    const energies = {};
    for (const [drum, profile] of Object.entries(drumProfiles)) {
      const startBin = Math.floor(profile.range[0] / binSize);
      const endBin = Math.min(fftSize, Math.ceil(profile.range[1] / binSize));
      let energy = 0;
      
      for (let i = startBin; i < endBin; i++) {
        energy += Math.pow(fftData[i] / 255, 2); // Square for energy emphasis
      }
      
      energies[drum] = energy / (endBin - startBin);
    }
    
    // Find drum with highest energy
    let maxEnergy = 0;
    let detectedDrum = null;
    const globalThreshold = parseFloat(sensitivitySlider.value);
    
    for (const [drum, energy] of Object.entries(energies)) {
      const threshold = Math.max(globalThreshold, drumProfiles[drum].threshold);
      if (energy > threshold * 1.5 && energy > maxEnergy * 1.5) {
        maxEnergy = energy;
        detectedDrum = drum;
      }
    }
    
    if (detectedDrum) {
      lastDrumType = detectedDrum;
      lastHitTime = now;
      hitCooldown = true;
      setTimeout(() => { hitCooldown = false; }, 50); // 50ms cooldown
      return detectedDrum;
    }
    
    return null;
  }

  // MODIFIED: Audio processing with strict hit control
  function processAudio() {
    if (!running) return;
    
    // Get frequency data
    const fftData = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(fftData);
    analyser.getFloatTimeDomainData(dataArray);
    
    // Detect drum hit
    const drumType = detectDrum(fftData, audioCtx.sampleRate);
    
    if (drumType) {
      hitCount++;
      hitsEl.textContent = hitCount;
      
      // Calculate center frequency
      const profile = drumProfiles[drumType];
      const centerFreq = (profile.range[0] + profile.range[1]) / 2;
      freqEl.textContent = `${centerFreq.toFixed(0)} Hz (${drumType.toUpperCase()})`;
      
      showDrumHit(drumType);
    }
    
    // Volume display (UNCHANGED)
    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) sum += dataArray[i] * dataArray[i];
    const rms = Math.sqrt(sum / dataArray.length);
    volumeEl.textContent = `${(20 * Math.log10(rms)).toFixed(1)} dB`;
    
    drawWaveform();
    animationId = requestAnimationFrame(processAudio);
  }

  // MODIFIED: Audio setup with aggressive compression
  async function startMic() {
    if (running) return;
    
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      
      // Add aggressive compressor
      const compressor = audioCtx.createDynamicsCompressor();
      compressor.threshold.value = -40; // More sensitive
      compressor.knee.value = 30;      // Smoother transition
      compressor.ratio.value = 16;     // Stronger compression
      compressor.attack.value = 0.003; // Faster response
      compressor.release.value = 0.1;  // Quick release
      
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      source = audioCtx.createMediaStreamSource(mediaStream);
      
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 1024; // Smaller FFT for faster analysis
      bufferLength = analyser.frequencyBinCount;
      dataArray = new Float32Array(analyser.fftSize);
      
      source.connect(compressor);
      compressor.connect(analyser);
      
      if (audioCtx.state === 'suspended') await audioCtx.resume();
      
      running = true;
      hitCount = 0;
      hitsEl.textContent = '0';
      freqEl.textContent = '-- Hz';
      volumeEl.textContent = '-- dB';
      
      startBtn.disabled = true;
      stopBtn.disabled = false;
      
      processAudio();
    } catch (err) {
      console.error("Audio error:", err);
      alert("Microphone access denied");
      stopMic();
    }
  }

  // UNCHANGED: stopMic() and init functions
  function stopMic() {
    running = false;
    cancelAnimationFrame(animationId);
    if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
    if (source) source.disconnect();
    if (analyser) analyser.disconnect();
    if (audioCtx?.state !== 'closed') audioCtx?.close();
    startBtn.disabled = false;
    stopBtn.disabled = true;
    ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
  }

  function initCanvas() {
    waveformCanvas.width = waveformCanvas.offsetWidth;
    waveformCanvas.height = waveformCanvas.offsetHeight;
  }
  
  window.addEventListener('load', initCanvas);
  window.addEventListener('resize', initCanvas);
  window.addEventListener('beforeunload', stopMic);

</script>
</body>
</html>