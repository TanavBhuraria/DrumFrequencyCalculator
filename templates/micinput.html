<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fixed Drum Analyzer</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 800px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      width: 100%;
      position: relative;
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      background: linear-gradient(90deg, #ff7e5f, #feb47b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .subtitle {
      font-size: 1.2rem;
      color: #a0a0d0;
      max-width: 600px;
      margin: 0 auto;
    }
    
    .visualization {
      width: 100%;
      height: 200px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      margin-bottom: 30px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .drum-display {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      gap: 10px;
      padding: 20px;
    }
    
    .drum-pad {
      width: 70px;
      height: 70px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2rem;
      font-weight: bold;
      color: rgba(255, 255, 255, 0.7);
      transition: all 50ms ease-out;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      will-change: transform, background-color;
    }
    
    .drum-pad.active {
      transform: scale(1.2);
      background: rgba(255, 126, 95, 0.8);
      box-shadow: 0 0 20px rgba(255, 126, 95, 0.7);
    }
    
    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    button {
      background: linear-gradient(135deg, #ff7e5f, #feb47b);
      color: white;
      border: none;
      padding: 14px 28px;
      font-size: 1.1rem;
      font-weight: 600;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 126, 95, 0.4);
      min-width: 180px;
    }
    
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(255, 126, 95, 0.6);
    }
    
    button:disabled {
      background: #555;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      width: 100%;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 25px;
      text-align: center;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .stat-card h2 {
      font-size: 1.3rem;
      margin-bottom: 15px;
      color: #a0a0d0;
    }
    
    .stat-value {
      font-size: 3.5rem;
      font-weight: 700;
      background: linear-gradient(90deg, #ff7e5f, #feb47b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .settings {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 25px;
      width: 100%;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .slider-container {
      margin-bottom: 20px;
    }
    
    .slider-container label {
      display: block;
      margin-bottom: 10px;
      font-size: 1.1rem;
      color: #a0a0d0;
      display: flex;
      justify-content: space-between;
    }
    
    .slider-container span {
      font-weight: bold;
      color: #ff7e5f;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ff7e5f;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(255, 126, 95, 0.7);
    }
    
    .canvas-container {
      width: 100%;
      height: 150px;
      margin-top: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }
    
    canvas {
      width: 100%;
      height: 100%;
    }
    
    .hit-indicator {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .hit-indicator.active {
      opacity: 1;
    }
    
    .harmonic-display {
      margin-top: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      padding: 15px;
      width: 100%;
    }
    
    .harmonic-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
    }
    
    .harmonic-header:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .harmonic-content {
      display: none;
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
    }
    
    .harmonic-content.show {
      display: block;
    }
    
    .harmonic-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 10px;
    }
    
    .harmonic-item {
      background: rgba(255, 255, 255, 0.05);
      padding: 10px;
      border-radius: 8px;
      text-align: center;
    }
    
    .harmonic-label {
      font-size: 0.9rem;
      color: #a0a0d0;
      margin-bottom: 5px;
    }
    
    .harmonic-value {
      font-size: 1.2rem;
      font-weight: bold;
      color: #ff7e5f;
    }
    
    .drum-info {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      padding: 15px;
      margin-top: 20px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .drum-info-title {
      font-size: 1.2rem;
      margin-bottom: 10px;
      color: #ff7e5f;
    }
    
    .drum-info-text {
      text-align: center;
      color: #a0a0d0;
      line-height: 1.6;
      max-width: 600px;
    }
    
    footer {
      margin-top: 40px;
      text-align: center;
      color: #777;
      font-size: 0.9rem;
      padding: 20px;
    }
    
    .debug-panel {
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      width: 100%;
      font-family: monospace;
    }
    
    .debug-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    
    .debug-label {
      color: #a0a0d0;
    }
    
    .debug-value {
      font-weight: bold;
    }
    
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }
    
    .status-active {
      background-color: #4caf50;
    }
    
    .status-inactive {
      background-color: #f44336;
    }
    
    .chart-container {
      width: 100%;
      height: 150px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      overflow: hidden;
      margin-top: 20px;
    }
    
    @media (max-width: 600px) {
      h1 {
        font-size: 2.2rem;
      }
      
      .stat-value {
        font-size: 2.8rem;
      }
      
      .drum-pad {
        width: 50px;
        height: 50px;
        font-size: 1rem;
      }
      
      button {
        min-width: 140px;
        padding: 12px 20px;
        font-size: 1rem;
      }
      
      .controls {
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Fixed Drum Analyzer</h1>
      <p class="subtitle">Real-time drum detection with peak detection</p>
    </header>
    
    <div class="visualization">
      <div class="drum-display">
        <div class="drum-pad" data-type="kick">KICK</div>
        <div class="drum-pad" data-type="snare">SNARE</div>
        <div class="drum-pad" data-type="hihat">HI-HAT</div>
        <div class="drum-pad" data-type="tom">TOM</div>
        <div class="drum-pad" data-type="cymbal">CYMBAL</div>
      </div>
    </div>
    
    <div class="controls">
      <button id="start-btn">Start Microphone</button>
      <button id="stop-btn" disabled>Stop Microphone</button>
      <button id="reset-btn">Reset Counter</button>
    </div>
    
    <div class="stats">
      <div class="stat-card">
        <h2>Hits Detected</h2>
        <div id="hits" class="stat-value">0</div>
      </div>
      
      <div class="stat-card">
        <h2>Detected Frequency</h2>
        <div id="frequency" class="stat-value">-- Hz</div>
      </div>
    </div>
    
    <div class="debug-panel">
      <div class="debug-row">
        <span class="debug-label">Microphone Status:</span>
        <span id="mic-status"><span class="status-indicator status-inactive"></span>Inactive</span>
      </div>
      <div class="debug-row">
        <span class="debug-label">Current Volume:</span>
        <span id="current-volume" class="debug-value">0.00</span>
      </div>
      <div class="debug-row">
        <span class="debug-label">Detection Threshold:</span>
        <span id="threshold" class="debug-value">0.05</span>
      </div>
      <div class="debug-row">
        <span class="debug-label">Last Drum Type:</span>
        <span id="last-drum" class="debug-value">--</span>
      </div>
    </div>
    
    <div class="settings">
      <div class="slider-container">
        <label>
          Detection Sensitivity
          <span id="sensitivity-val">0.05</span>
        </label>
        <input type="range" id="sensitivity-slider" min="0.01" max="0.15" step="0.01" value="0.05">
      </div>
      
      <div class="canvas-container">
        <canvas id="waveform"></canvas>
      </div>
      
      <div class="chart-container">
        <canvas id="volume-chart"></canvas>
      </div>
    </div>
    
    <div class="drum-info">
      <div class="drum-info-title">How Peak Detection Works</div>
      <div class="drum-info-text">
        The fixed analyzer now detects drum hits by measuring volume peaks. When the audio volume exceeds the threshold, it registers a hit. The algorithm ensures only distinct hits are counted by implementing a cooldown period between detections.
      </div>
    </div>
  </div>
  
  <div class="hit-indicator" id="hit-indicator"></div>
  
  <footer>
    <p>Fixed Drum Analyzer | Peak Detection Algorithm</p>
  </footer>

  <script>
    // DOM Elements
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const resetBtn = document.getElementById('reset-btn');
    const hitsEl = document.getElementById('hits');
    const freqEl = document.getElementById('frequency');
    const sensitivitySlider = document.getElementById('sensitivity-slider');
    const sensitivityVal = document.getElementById('sensitivity-val');
    const hitIndicator = document.getElementById('hit-indicator');
    const waveformCanvas = document.getElementById('waveform');
    const volumeCanvas = document.getElementById('volume-chart');
    const drumPads = document.querySelectorAll('.drum-pad');
    const micStatus = document.getElementById('mic-status');
    const currentVolume = document.getElementById('current-volume');
    const thresholdEl = document.getElementById('threshold');
    const lastDrumEl = document.getElementById('last-drum');
    
    // Audio variables
    let audioCtx = null;
    let analyser = null;
    let source = null;
    let mediaStream = null;
    let dataArray = null;
    let animationId = null;
    let bufferLength = null;
    
    // State variables
    let running = false;
    let hitCount = 0;
    let lastDrumType = null;
    let lastHitTime = 0;
    const HIT_COOLDOWN = 200; // ms
    
    // Volume history for visualization
    const volumeHistory = new Array(100).fill(0);
    let currentIndex = 0;
    
    // Initialize UI
    sensitivityVal.textContent = sensitivitySlider.value;
    thresholdEl.textContent = sensitivitySlider.value;
    
    // Event listeners
    startBtn.addEventListener('click', startMic);
    stopBtn.addEventListener('click', stopMic);
    resetBtn.addEventListener('click', () => {
      hitCount = 0;
      hitsEl.textContent = hitCount;
      freqEl.textContent = '-- Hz';
      lastDrumEl.textContent = '--';
    });
    
    sensitivitySlider.addEventListener('input', () => {
      sensitivityVal.textContent = sensitivitySlider.value;
      thresholdEl.textContent = sensitivitySlider.value;
    });
    
    // Visual feedback for drum hit
    function showDrumHit(drumType) {
      const profile = getDrumProfile(drumType);
      
      // Pad animation
      drumPads.forEach(pad => {
        if (pad.dataset.type === drumType) {
          pad.classList.add('active');
          setTimeout(() => pad.classList.remove('active'), profile.decay);
        }
      });
      
      // Screen flash
      hitIndicator.style.background = `radial-gradient(circle, ${profile.color}77 0%, transparent 70%)`;
      hitIndicator.classList.add('active');
      setTimeout(() => hitIndicator.classList.remove('active'), profile.decay);
      
      // Update last drum display
      lastDrumEl.textContent = drumType.toUpperCase();
    }
    
    // Get drum profile
    function getDrumProfile(drumType) {
      return {
        kick: { range: [30, 100], color: '#ff5e5e', decay: 150 },
        snare: { range: [100, 300], color: '#5effae', decay: 120 },
        hihat: { range: [3000, 8000], color: '#5eb3ff', decay: 80 },
        tom: { range: [80, 200], color: '#ffbe5e', decay: 100 },
        cymbal: { range: [3000, 10000], color: '#d85eff', decay: 60 }
      }[drumType];
    }
    
    // Draw waveform visualization
    function drawWaveform() {
      if (!analyser || !running) return;
      
      analyser.getFloatTimeDomainData(dataArray);
      
      const ctx = waveformCanvas.getContext('2d');
      ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
      ctx.beginPath();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#ff7e5f';
      ctx.filter = 'blur(0.5px)';
      
      const sliceWidth = waveformCanvas.width / bufferLength;
      let x = 0;
      
      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i];
        const y = waveformCanvas.height/2 + (v * waveformCanvas.height/2);
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
        
        x += sliceWidth;
      }
      
      ctx.stroke();
      ctx.filter = 'none';
    }
    
    // Draw volume chart
    function drawVolumeChart() {
      const ctx = volumeCanvas.getContext('2d');
      ctx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);
      
      // Draw threshold line
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255, 126, 95, 0.5)';
      ctx.lineWidth = 2;
      const thresholdY = volumeCanvas.height - (parseFloat(sensitivitySlider.value) * volumeCanvas.height * 10);
      ctx.moveTo(0, thresholdY);
      ctx.lineTo(volumeCanvas.width, thresholdY);
      ctx.stroke();
      
      // Draw volume line
      ctx.beginPath();
      ctx.strokeStyle = '#4caf50';
      ctx.lineWidth = 2;
      
      for (let i = 0; i < volumeHistory.length; i++) {
        const x = (i / volumeHistory.length) * volumeCanvas.width;
        const y = volumeCanvas.height - (volumeHistory[i] * volumeCanvas.height * 10);
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      ctx.stroke();
    }
    
    // Detect drum type and frequency
    function detectDrum(fftData, sampleRate) {
      const fftSize = fftData.length;
      const binSize = sampleRate / analyser.fftSize;
      
      // Find the bin with the highest amplitude (skip first 10 bins to avoid DC offset)
      let maxIndex = 10;
      let maxValue = 0;
      for (let i = 10; i < fftSize / 2; i++) {
        if (fftData[i] > maxValue) {
          maxValue = fftData[i];
          maxIndex = i;
        }
      }
      
      // Calculate frequency
      const frequency = maxIndex * binSize;
      
      // Classify drum type based on frequency ranges
      let drumType = 'kick';
      if (frequency > 100 && frequency <= 300) drumType = 'snare';
      else if (frequency > 300 && frequency <= 800) drumType = 'tom';
      else if (frequency > 800 && frequency <= 3000) drumType = 'hihat';
      else if (frequency > 3000) drumType = 'cymbal';
      
      return { drumType, frequency };
    }
    
    // Audio processing loop with PEAK DETECTION
    function processAudio() {
      if (!running) return;

      // Get time domain data
      analyser.getFloatTimeDomainData(dataArray);
      
      // Calculate RMS (root mean square) volume
      let sum = 0;
      for (let i = 0; i < bufferLength; i++) {
        sum += dataArray[i] * dataArray[i];
      }
      const rms = Math.sqrt(sum / bufferLength);
      
      // Update volume history
      volumeHistory[currentIndex] = rms;
      currentIndex = (currentIndex + 1) % volumeHistory.length;
      
      // Update debug display
      currentVolume.textContent = rms.toFixed(4);
      
      // Check for drum hit based on VOLUME PEAK
      const now = Date.now();
      const threshold = parseFloat(sensitivitySlider.value);
      
      // Only detect a hit if above threshold and cooldown has passed
      if (rms > threshold && now - lastHitTime > HIT_COOLDOWN) {
        // Get FFT data for frequency analysis
        const fftData = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(fftData);
        
        // Detect drum type and frequency
        const detectionResult = detectDrum(fftData, audioCtx.sampleRate);
        
        if (detectionResult) {
          hitCount++;
          hitsEl.textContent = hitCount;
          freqEl.textContent = `${detectionResult.frequency.toFixed(0)} Hz (${detectionResult.drumType.toUpperCase()})`;
          showDrumHit(detectionResult.drumType);
          lastHitTime = now;
        }
      }
      
      drawWaveform();
      drawVolumeChart();
      animationId = requestAnimationFrame(processAudio);
    }
    
    // Start microphone processing
    async function startMic() {
      if (running) return;
      
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // Setup compressor for better dynamics
        const compressor = audioCtx.createDynamicsCompressor();
        compressor.threshold.value = -30;
        compressor.knee.value = 20;
        compressor.ratio.value = 12;
        compressor.attack.value = 0.003;
        compressor.release.value = 0.25;
        
        // Get microphone
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        source = audioCtx.createMediaStreamSource(mediaStream);
        
        // Setup analyser with higher resolution
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 4096;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Float32Array(bufferLength);
        
        // Connect nodes
        source.connect(compressor);
        compressor.connect(analyser);
        
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        
        running = true;
        hitCount = 0;
        hitsEl.textContent = '0';
        freqEl.textContent = '-- Hz';
        lastDrumEl.textContent = '--';
        
        startBtn.disabled = true;
        stopBtn.disabled = false;
        
        // Update status
        micStatus.innerHTML = '<span class="status-indicator status-active"></span>Active';
        
        // Initialize canvases
        waveformCanvas.width = waveformCanvas.offsetWidth;
        waveformCanvas.height = waveformCanvas.offsetHeight;
        volumeCanvas.width = volumeCanvas.offsetWidth;
        volumeCanvas.height = volumeCanvas.offsetHeight;
        
        processAudio();
      } catch (err) {
        console.error("Audio setup failed:", err);
        alert("Couldn't access microphone. Please check permissions and try again.");
        stopMic();
      }
    }
    
    // Stop microphone processing
    function stopMic() {
      running = false;
      cancelAnimationFrame(animationId);
      
      if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
      if (source) source.disconnect();
      if (analyser) analyser.disconnect();
      if (audioCtx?.state !== 'closed') audioCtx?.close();
      
      startBtn.disabled = false;
      stopBtn.disabled = true;
      
      // Clear canvases
      const waveformCtx = waveformCanvas.getContext('2d');
      waveformCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
      
      const volumeCtx = volumeCanvas.getContext('2d');
      volumeCtx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);
      
      // Update status
      micStatus.innerHTML = '<span class="status-indicator status-inactive"></span>Inactive';
      currentVolume.textContent = '0.00';
    }
    
    // Initialize on load
    window.addEventListener('load', () => {
      waveformCanvas.width = waveformCanvas.offsetWidth;
      waveformCanvas.height = waveformCanvas.offsetHeight;
      
      volumeCanvas.width = volumeCanvas.offsetWidth;
      volumeCanvas.height = volumeCanvas.offsetHeight;
    });
    
    window.addEventListener('resize', () => {
      if (running) {
        waveformCanvas.width = waveformCanvas.offsetWidth;
        waveformCanvas.height = waveformCanvas.offsetHeight;
        
        volumeCanvas.width = volumeCanvas.offsetWidth;
        volumeCanvas.height = volumeCanvas.offsetHeight;
      }
    });
    
    window.addEventListener('beforeunload', stopMic);
  </script>
</body>
</html>