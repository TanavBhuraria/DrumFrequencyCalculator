<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Professional Drum Frequency Analyzer</title>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  background: linear-gradient(135deg, #1a1a2e, #16213e);
  color: #fff;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  padding: 20px;
  display: flex;
  justify-content: center;
  min-height: 100vh;
}

.container {
  max-width: 1000px;
  width: 100%;
  padding: 20px;
}

header {
  text-align: center;
  margin-bottom: 25px;
  padding-bottom: 20px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

h1 {
  font-size: 2.5rem;
  background: linear-gradient(90deg, #ff7e5f, #feb47b);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 10px;
}

.subtitle {
  color: #a0a0d0;
  font-size: 1.1rem;
}

.visualization {
  background: rgba(0, 0, 0, 0.28);
  border-radius: 12px;
  margin-bottom: 20px;
  position: relative;
  overflow: hidden;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
  height: 300px;
}

#waveformCanvas {
  width: 100%;
  height: 100%;
  display: block;
}

.drum-display {
  position: absolute;
  bottom: 0;
  width: 100%;
  display: flex;
  justify-content: center;
  gap: 15px;
  padding: 20px;
  pointer-events: none;
}

.drum-pad {
  pointer-events: none;
  width: 80px;
  height: 80px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.08);
  color: rgba(255, 255, 255, 0.85);
  font-weight: bold;
  transition: all 300ms ease;
  font-size: 1rem;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

.drum-pad.active {
  transform: scale(1.18);
  background: linear-gradient(135deg, #ff7e5f, #feb47b);
  box-shadow: 0 0 25px rgba(255, 126, 95, 0.7);
  color: #fff;
  z-index: 10;
}

.controls {
  display: flex;
  gap: 15px;
  margin-bottom: 20px;
  flex-wrap: wrap;
  justify-content: center;
}

button {
  background: linear-gradient(135deg, #ff7e5f, #feb47b);
  color: #fff;
  border: none;
  padding: 14px 22px;
  border-radius: 50px;
  cursor: pointer;
  font-weight: 600;
  font-size: 1rem;
  min-width: 120px;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(255, 126, 95, 0.4);
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(255, 126, 95, 0.6);
}

button:disabled {
  background: #555;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.stats-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-bottom: 20px;
}

.stats {
  background: rgba(255, 255, 255, 0.04);
  border-radius: 12px;
  padding: 20px;
}

.stat-card {
  margin-bottom: 15px;
}

.stat-card h2 {
  font-size: 1.1rem;
  margin-bottom: 8px;
  color: #a0a0d0;
}

.stat-value {
  font-size: 2.4rem;
  font-weight: 700;
  background: linear-gradient(90deg, #ff7e5f, #feb47b);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.confidence-bar {
  margin-top: 15px;
  background: rgba(255, 255, 255, 0.08);
  border-radius: 6px;
  height: 12px;
  overflow: hidden;
}

.confidence-fill {
  height: 100%;
  background: linear-gradient(90deg, #f44336, #4caf50);
  transition: width 0.5s ease;
}

.confidence-labels {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
  color: #a0a0d0;
  font-size: 0.9rem;
}

.spectrum-container {
  background: rgba(0, 0, 0, 0.15);
  border-radius: 8px;
  padding: 15px;
  margin-top: 20px;
}

.spectrum-display {
  display: flex;
  gap: 3px;
  align-items: flex-end;
  height: 150px;
  margin-bottom: 10px;
}

.spectrum-bar {
  flex: 1;
  min-width: 4px;
  border-radius: 4px 4px 0 0;
  background: linear-gradient(to top, #ff7e5f, #feb47b);
  transition: height 0.1s ease;
}

.frequency-range {
  display: flex;
  justify-content: space-between;
  color: #a0a0d0;
  font-size: 0.9rem;
}

.harmonics {
  background: rgba(0, 0, 0, 0.12);
  border-radius: 8px;
  padding: 20px;
  margin-top: 20px;
}

.harmonics-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.harmonic-list {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 15px;
}

.harmonic-item {
  background: rgba(255, 255, 255, 0.03);
  padding: 15px;
  border-radius: 8px;
  text-align: center;
}

.harmonic-value {
  font-size: 1.4rem;
  font-weight: bold;
  margin-top: 8px;
  color: #feb47b;
}

.info-box {
  background: rgba(255, 126, 95, 0.08);
  padding: 15px;
  border-radius: 8px;
  margin-top: 20px;
  font-size: 0.95rem;
  line-height: 1.5;
}

.debug-panel {
  background: rgba(0, 0, 0, 0.7);
  color: #fff;
  padding: 15px;
  border-radius: 8px;
  margin-top: 20px;
  font-family: monospace;
  font-size: 0.95rem;
}

.debug-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
  padding-bottom: 8px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.persistent-display {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 80px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  margin-top: 15px;
  font-size: 1.4rem;
  color: #feb47b;
  font-weight: bold;
}

@media (max-width: 768px) {
  .stats-container {
    grid-template-columns: 1fr;
  }
  
  .drum-pad {
    width: 65px;
    height: 65px;
    font-size: 0.9rem;
  }
  
  .controls {
    flex-direction: column;
    align-items: center;
  }
  
  button {
    width: 100%;
    max-width: 300px;
  }
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Professional Drum Frequency Analyzer</h1>
    <p class="subtitle">Audacity-level precision with 3-second persistence</p>
  </header>
  
  <div class="visualization">
    <canvas id="waveformCanvas"></canvas>
    <div class="drum-display" id="drumDisplay">
      <div class="drum-pad">Kick</div>
      <div class="drum-pad">Snare</div>
      <div class="drum-pad">Hi-Hat</div>
      <div class="drum-pad">Tom 1</div>
      <div class="drum-pad">Tom 2</div>
      <div class="drum-pad">Floor</div>
    </div>
  </div>
  
  <div class="controls">
    <button id="startBtn">Start Analysis</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="calBtn">Calibrate</button>
    <button id="snapBtn">Save Data</button>
  </div>
  
  <div class="stats-container">
    <div class="stats">
      <div class="stat-card">
        <h2>Fundamental Frequency</h2>
        <div class="stat-value" id="fundamental">-- Hz</div>
      </div>
      
      <div class="persistent-display" id="persistentDisplay">
        Last detection: --
      </div>
      
      <div class="stat-card">
        <h2>Signal Confidence</h2>
        <div class="confidence-bar">
          <div class="confidence-fill" id="confBar"></div>
        </div>
        <div class="confidence-labels">
          <span>Low</span>
          <span id="confLabel">0%</span>
          <span>High</span>
        </div>
      </div>
    </div>
    
    <div class="stats">
      <div class="stat-card">
        <h2>Peak Amplitude</h2>
        <div class="stat-value" id="peakDb">-- dB</div>
      </div>
      
      <div class="stat-card">
        <h2>FFT Resolution</h2>
        <div class="stat-value" id="fftRes">±5 Hz</div>
      </div>
      
      <div class="stat-card">
        <h2>Sensitivity</h2>
        <input id="sensitivity" type="range" min="0.05" max="0.2" step="0.005" value="0.12" />
        <div style="text-align: center; margin-top: 8px;">
          <span id="sensValue">0.120</span>
        </div>
      </div>
    </div>
  </div>
  
  <div class="spectrum-container">
    <div class="spectrum-display" id="bars"></div>
    <div class="frequency-range">
      <span>20 Hz</span>
      <span>200 Hz</span>
      <span>2 kHz</span>
      <span>20 kHz</span>
    </div>
  </div>
  
  <div class="harmonics">
    <div class="harmonics-header">
      <strong>Harmonics Analysis</strong>
      <span style="color:#a0a0d0">Multiples of Fundamental</span>
    </div>
    <div class="harmonic-list">
      <div class="harmonic-item">
        <div>1× Fundamental</div>
        <div class="harmonic-value" id="h1">-- Hz</div>
      </div>
      <div class="harmonic-item">
        <div>2× Harmonic</div>
        <div class="harmonic-value" id="h2">-- Hz</div>
      </div>
      <div class="harmonic-item">
        <div>3× Harmonic</div>
        <div class="harmonic-value" id="h3">-- Hz</div>
      </div>
      <div class="harmonic-item">
        <div>4× Harmonic</div>
        <div class="harmonic-value" id="h4">-- Hz</div>
      </div>
    </div>
  </div>
  
  <div class="info-box">
    <strong>Calibration Tip:</strong> Perform calibration in a quiet environment. For best results, 
    position your microphone 1-2 feet from the drum kit. Adjust sensitivity after calibration 
    to reduce false triggers.
  </div>
  
  <div class="debug-panel">
    <div class="debug-row">
      <div>Status:</div>
      <div id="status">Ready to start</div>
    </div>
    <div class="debug-row">
      <div>FFT Size:</div>
      <div id="fftSize">8192 samples</div>
    </div>
    <div class="debug-row">
      <div>Sample Rate:</div>
      <div id="sampleRate">-- Hz</div>
    </div>
    <div class="debug-row">
      <div>Last Detection:</div>
      <div id="lastDetectionTime">--</div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // Elements
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const calBtn = document.getElementById('calBtn');
  const snapBtn = document.getElementById('snapBtn');
  const waveformCanvas = document.getElementById('waveformCanvas');
  const ctx = waveformCanvas.getContext('2d');
  const barsContainer = document.getElementById('bars');
  const sensEl = document.getElementById('sensitivity');
  const sensVal = document.getElementById('sensValue');
  const confBar = document.getElementById('confBar');
  const confLbl = document.getElementById('confLabel');
  const fundEl = document.getElementById('fundamental');
  const peakEl = document.getElementById('peakDb');
  const h1 = document.getElementById('h1');
  const h2 = document.getElementById('h2');
  const h3 = document.getElementById('h3');
  const h4 = document.getElementById('h4');
  const statusEl = document.getElementById('status');
  const sampleRateEl = document.getElementById('sampleRate');
  const persistentDisplay = document.getElementById('persistentDisplay');
  const lastDetectionTimeEl = document.getElementById('lastDetectionTime');
  const fftResEl = document.getElementById('fftRes');
  
  // Prepare spectrum bars
  const BAR_COUNT = 128;
  function makeBars() {
    barsContainer.innerHTML = '';
    for (let i = 0; i < BAR_COUNT; i++) {
      const bar = document.createElement('div');
      bar.className = 'spectrum-bar';
      bar.style.height = '4px';
      barsContainer.appendChild(bar);
    }
  }
  makeBars();
  
  // Audio variables
  let audioCtx = null;
  let analyser = null;
  let source = null;
  let stream = null;
  let floatFreq = null;
  let timeData = null;
  let noiseFloor = null;
  let isRunning = false;
  let rafId = null;
  
  // Detection state
  let lastDetectedFrequency = null;
  let lastDetectionTime = 0;
  const PERSISTENCE_TIME = 3000; // 3 seconds
  let snapshot = [];
  
  // Thresholds and configs
  const SNR_THRESHOLD = 8; // dB
  const CONFIDENCE_THRESHOLD = 0.2;
  const NOISE_SILENCE_DB = -80;
  const ABS_MAG_THRESHOLD = 1e-6;
  const MAX_FREQ_DETECT = 300; // Hz
  const MIN_FREQ_DETECT = 20; // Hz
  const FFT_SIZE = 16384; // Better resolution (±2.7Hz at 44.1kHz)
  
  // Resize canvas for waveform display
  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const w = waveformCanvas.clientWidth;
    const h = waveformCanvas.clientHeight;
    waveformCanvas.width = Math.max(1, Math.floor(w * dpr));
    waveformCanvas.height = Math.max(1, Math.floor(h * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
  
  // Sensitivity control
  sensVal.textContent = parseFloat(sensEl.value).toFixed(3);
  sensEl.addEventListener('input', () => {
    sensVal.textContent = parseFloat(sensEl.value).toFixed(3);
  });
  
  // Button event listeners
  startBtn.addEventListener('click', start);
  stopBtn.addEventListener('click', stop);
  calBtn.addEventListener('click', () => {
    if (analyser) calibrateNoise(1.5);
  });
  snapBtn.addEventListener('click', saveCSV);
  
  // Initialize application
  function init() {
    statusEl.textContent = 'Ready to start';
    sampleRateEl.textContent = '-- Hz';
    lastDetectionTimeEl.textContent = '--';
    fftResEl.textContent = `±${(44100 / FFT_SIZE).toFixed(2)} Hz`;
  }
  
  // Start audio analysis
  async function start() {
    if (isRunning) return;
    statusEl.textContent = 'Starting...';
    
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sampleRateEl.textContent = `${audioCtx.sampleRate} Hz`;
      
      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      source = audioCtx.createMediaStreamSource(stream);
      
      analyser = audioCtx.createAnalyser();
      analyser.smoothingTimeConstant = 0.5;
      analyser.minDecibels = -120;
      analyser.maxDecibels = -10;
      analyser.fftSize = FFT_SIZE;
      
      source.connect(analyser);
      
      floatFreq = new Float32Array(analyser.frequencyBinCount);
      timeData = new Float32Array(analyser.fftSize);
      noiseFloor = new Float32Array(analyser.frequencyBinCount).fill(1e-12);
      
      isRunning = true;
      statusEl.textContent = 'Running - calibrating...';
      startBtn.disabled = true;
      stopBtn.disabled = false;
      
      await calibrateNoise(1.5);
      visualize();
    } catch (e) {
      console.error('Audio setup failed:', e);
      statusEl.textContent = `Error: ${e.message}`;
      alert(`Microphone access failed: ${e.message}`);
      stop();
    }
  }
  
  // Stop audio analysis
  function stop() {
    if (!isRunning) return;
    isRunning = false;
    
    if (rafId) {
      cancelAnimationFrame(rafId);
      rafId = null;
    }
    
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
      stream = null;
    }
    
    if (source) source.disconnect();
    if (analyser) analyser.disconnect();
    
    if (audioCtx) {
      audioCtx.close().catch(() => {})
        .then(() => {
          audioCtx = null;
          statusEl.textContent = 'Stopped';
          startBtn.disabled = false;
          stopBtn.disabled = true;
        });
    }
    
    // Reset UI
    fundEl.textContent = '-- Hz';
    peakEl.textContent = '-- dB';
    confBar.style.width = '0%';
    confLbl.textContent = '0%';
    [h1, h2, h3, h4].forEach(el => el.textContent = '-- Hz');
    persistentDisplay.textContent = 'Last detection: --';
    lastDetectionTimeEl.textContent = '--';
    deactivatePads();
  }
  
  // Calibrate noise floor
  async function calibrateNoise(duration = 1.5) {
    if (!analyser) return;
    statusEl.textContent = 'Calibrating noise floor...';
    
    const acc = new Float32Array(analyser.frequencyBinCount).fill(0);
    let frames = 0;
    const startTime = performance.now();
    
    while (performance.now() - startTime < duration * 1000) {
      analyser.getFloatFrequencyData(floatFreq);
      
      for (let i = 0; i < floatFreq.length; i++) {
        // Convert dB to linear magnitude
        acc[i] += Math.pow(10, floatFreq[i] / 20);
      }
      
      frames++;
      await new Promise(resolve => setTimeout(resolve, 40));
    }
    
    if (frames > 0) {
      for (let i = 0; i < acc.length; i++) {
        noiseFloor[i] = acc[i] / frames + 1e-12;
      }
    }
    
    statusEl.textContent = 'Calibration complete';
  }
  
  // Save data to CSV
  function saveCSV() {
    if (!snapshot || snapshot.length === 0) {
      alert('No data collected yet. Start analysis and detect some drum hits first.');
      return;
    }
    
    const header = ['timestamp_ms', 'freq_hz', 'peak_db', 'confidence'];
    const rows = [header.join(',')].concat(snapshot.map(row => row.join(',')));
    const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'drum_frequencies.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }
  
  // Activate drum pad
  function activatePad(name) {
    document.querySelectorAll('.drum-pad').forEach(pad => {
      if (pad.textContent === name) {
        pad.classList.add('active');
      } else {
        pad.classList.remove('active');
      }
    });
  }
  
  // Deactivate all drum pads
  function deactivatePads() {
    document.querySelectorAll('.drum-pad').forEach(pad => {
      pad.classList.remove('active');
    });
  }
  
  function findDominantFrequency(mags, sampleRate, fftSize) {
    const binSize = sampleRate / fftSize;
    const minBin = Math.floor(MIN_FREQ_DETECT / binSize);
    const maxBin = Math.min(Math.floor(MAX_FREQ_DETECT / binSize), mags.length - 1);
    
    let maxMag = 0;
    let maxBinIdx = minBin;
    
    for (let i = minBin; i <= maxBin; i++) {
      if (mags[i] > maxMag) {
        maxMag = mags[i];
        maxBinIdx = i;
      }
    }
    
    // Quadratic interpolation for precise frequency
    let deltaFreq = 0;
    if (maxMag > 0 && maxBinIdx > 0 && maxBinIdx < mags.length - 1) {
      const alpha = mags[maxBinIdx - 1];
      const beta = mags[maxBinIdx];
      const gamma = mags[maxBinIdx + 1];
      const denom = alpha - 2 * beta + gamma;
      
      if (Math.abs(denom) > 1e-12) {
        deltaFreq = 0.5 * (alpha - gamma) / denom;
      }
    }
    
    return {
      freq: (maxBinIdx + deltaFreq) * binSize,
      bin: maxBinIdx,
      mag: maxMag
    };
  }
  
  // Draw spectrum bars
  function drawBars(mags, highlightBin = -1) {
    const bars = document.querySelectorAll('.spectrum-bar');
    const binStep = Math.floor(mags.length / bars.length);
    
    for (let i = 0; i < bars.length; i++) {
      const binIndex = Math.min(Math.floor(i * binStep), mags.length - 1);
      const mag = mags[binIndex] || 0;
      
      // Scale magnitude for display
      const heightPx = Math.max(4, Math.min(150, mag * 500));
      bars[i].style.height = `${heightPx}px`;
      
      // Highlight detected frequency bin
      if (highlightBin >= 0 && Math.abs(binIndex - highlightBin) <= 3) {
        bars[i].style.background = 'linear-gradient(to top, #4caf50, #8bc34a)';
      } else {
        bars[i].style.background = 'linear-gradient(to top, #ff7e5f, #feb47b)';
      }
    }
  }
  
  // Draw waveform
  function drawWaveform() {
    if (!analyser || !timeData) return;
    
    analyser.getFloatTimeDomainData(timeData);
    const width = waveformCanvas.width / window.devicePixelRatio;
    const height = waveformCanvas.height / window.devicePixelRatio;
    const centerY = height / 2;
    
    ctx.clearRect(0, 0, width, height);
    
    // Draw grid
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, centerY);
    ctx.lineTo(width, centerY);
    ctx.stroke();
    
    // Draw waveform
    ctx.strokeStyle = '#ff7e5f';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    const sliceWidth = width / timeData.length;
    let x = 0;
    
    for (let i = 0; i < timeData.length; i++) {
      const y = centerY + timeData[i] * centerY * 0.8;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
      
      x += sliceWidth;
    }
    
    ctx.stroke();
  }
  
  // Main visualization loop
  function visualize() {
    if (!isRunning || !analyser) return;
    rafId = requestAnimationFrame(visualize);
    
    analyser.getFloatFrequencyData(floatFreq);
    analyser.getFloatTimeDomainData(timeData);
    drawWaveform();
    
    const N = floatFreq.length;
    const sr = audioCtx ? audioCtx.sampleRate : 44100;
    const freqRes = sr / analyser.fftSize;

    // Convert dB to magnitude
    const mags = new Float32Array(N);
    let maxDbFrame = -Infinity;
    
    for (let i = 0; i < N; i++) {
      const mag = Math.pow(10, floatFreq[i] / 20);
      mags[i] = mag < ABS_MAG_THRESHOLD ? 0 : mag;
      if (floatFreq[i] > maxDbFrame) maxDbFrame = floatFreq[i];
    }
    
    // Static noise gating: ignore low energy frames
    if (maxDbFrame < NOISE_SILENCE_DB) {
      // Only update UI if we're not in persistence period
      if (Date.now() - lastDetectionTime > PERSISTENCE_TIME) {
        fundEl.textContent = '-- Hz';
        peakEl.textContent = '-- dB';
        confBar.style.width = '0%';
        confLbl.textContent = '0%';
        [h1, h2, h3, h4].forEach(el => el.textContent = '-- Hz');
        deactivatePads();
      }
      drawBars(mags);
      return;
    }
    
    // Find dominant frequency
    const { freq, bin, mag } = findDominantFrequency(mags, sr, analyser.fftSize);
    const confidence = Math.min(1, Math.max(0, mag * parseFloat(sensEl.value) * 10));
    
    // Update detection if confidence is above threshold
    if (confidence > CONFIDENCE_THRESHOLD) {
      lastDetectedFrequency = freq;
      lastDetectionTime = Date.now();
      lastDetectionTimeEl.textContent = new Date(lastDetectionTime).toLocaleTimeString();
      
      // Map frequency to drum type
      if (freq >= 40 && freq <= 90) {
        activatePad('Kick');
      } else if (freq > 90 && freq <= 180) {
        activatePad('Snare');
      } else if (freq > 180 && freq <= 250) {
        activatePad('Hi-Hat');
      } else if (freq > 250 && freq <= 300) {
        activatePad('Tom 1');
      } else {
        deactivatePads();
      }
      
      // Update UI
      fundEl.textContent = `${freq.toFixed(1)} Hz`;
      peakEl.textContent = `${maxDbFrame.toFixed(1)} dB`;
      confBar.style.width = `${confidence * 100}%`;
      confLbl.textContent = `${(confidence * 100).toFixed(0)}%`;
      
      // Update harmonic info
      [h1, h2, h3, h4].forEach((el, i) => {
        el.textContent = `${(freq * (i + 1)).toFixed(1)} Hz`;
      });
      
      // Save snapshot
      snapshot.push([Date.now(), freq.toFixed(1), maxDbFrame.toFixed(1), confidence.toFixed(2)]);
      if (snapshot.length > 2000) snapshot.shift();
    }
    
    // Update persistent display
    if (lastDetectedFrequency && Date.now() - lastDetectionTime <= PERSISTENCE_TIME) {
      persistentDisplay.textContent = `Last detection: ${lastDetectedFrequency.toFixed(1)} Hz`;
    } else if (Date.now() - lastDetectionTime > PERSISTENCE_TIME) {
      persistentDisplay.textContent = 'Last detection: --';
      deactivatePads();
    }
    
    // Draw spectrum
    drawBars(mags, bin);
  }
  
  // Initialize the app
  init();
});
</script>
</body>
</html>