<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Drum Frequency Analyzer — Harmonic-corrected</title>
<style>
  body{background:#16213e;color:#fff;font-family:Segoe UI, Tahoma, Geneva, Verdana, sans-serif;
    display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;margin:0;padding:20px;text-align:center}
  h1{color:#feb47b;margin-bottom:14px}
  .record-btn{background:linear-gradient(135deg,#ff7e5f,#feb47b);color:#fff;border:none;padding:16px 34px;border-radius:50px;cursor:pointer;font-weight:700;font-size:1.05rem;box-shadow:0 6px 18px rgba(0,0,0,.25)}
  .record-btn.recording{background:linear-gradient(135deg,#f44336,#ff7e5f)}
  .result{font-size:2.6rem;font-weight:800;margin:18px 0;color:#feb47b;min-height:56px}
  .status{color:#a0a0d0;margin-top:12px;font-size:.95rem}
  .small{font-size:.88rem;color:#bfbfdc;margin-top:6px}
  .debug {font-size:.8rem;color:#bfbfdc;margin-top:10px;opacity:.9}
</style>
</head>
<body>
  <h1>Drum Frequency Analyzer — Harmonic-corrected</h1>
  <button id="recordBtn" class="record-btn">Click to Record</button>
  <div class="result" id="result">-- Hz</div>
  <div class="status" id="status">Ready. Open console for debug logs.</div>
  <div class="small">Tip: test close to the mic. Use Chrome/Edge. Localhost/HTTPS recommended.</div>
  <div class="debug" id="debug"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const recordBtn = document.getElementById('recordBtn');
  const resultEl = document.getElementById('result');
  const statusEl = document.getElementById('status');
  const debugEl = document.getElementById('debug');

  let audioContext = null;
  let analyser = null;
  let micSource = null;
  let scriptNode = null;
  let isRecording = false;

  // Params
  const FFT_SIZE = 8192;             // large for good low-freq resolution
  const PROCESSOR_SIZE = 2048;       // script processor buffer
  const SMOOTH_WINDOW = 7;           // median smoothing window
  const HOLD_MS = 260;               // hold display after last good read
  const MIN_VOLUME = 0.0006;         // absolute minimum RMS to consider
  let noiseFloor = 0.002;            // adaptive noise floor (EMA)

  // Drum expected band (we'll attempt to pull f0 into this)
  const DRUM_MIN = 40;    // floor toms, low drums
  const DRUM_MAX = 250;   // snares/toms typical upper bound for fundamentals

  // smoothing & state
  let freqBuffer = [];
  let lastDisplayTime = 0;
  let lastShownFreq = null;

  // debug toggles
  const LOG = false;

  recordBtn.addEventListener('click', async () => {
    if (isRecording) {
      stop();
      recordBtn.classList.remove('recording');
      recordBtn.textContent = 'Click to Record';
      statusEl.textContent = 'Stopped';
    } else {
      try {
        await start();
        recordBtn.classList.add('recording');
        recordBtn.textContent = 'Recording... Click to Stop';
        statusEl.textContent = 'Live — hit the drum';
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Error: ' + (err && err.message ? err.message : err);
      }
    }
  });

  async function start() {
    if (isRecording) return;
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    analyser.fftSize = FFT_SIZE;
    analyser.smoothingTimeConstant = 0.0;

    scriptNode = audioContext.createScriptProcessor(PROCESSOR_SIZE, 1, 1);
    scriptNode.onaudioprocess = () => {
      if (!isRecording) return;
      processFrame();
    };

    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        channelCount: 1,
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    });

    micSource = audioContext.createMediaStreamSource(stream);
    micSource.connect(analyser);
    analyser.connect(scriptNode);
    scriptNode.connect(audioContext.destination);

    isRecording = true;
    console.log('Started — sampleRate:', audioContext.sampleRate, 'fftSize:', analyser.fftSize);
  }

  function stop() {
    if (!isRecording) return;
    isRecording = false;

    try {
      if (micSource) {
        micSource.mediaStream.getTracks().forEach(t => t.stop());
        micSource.disconnect();
      }
    } catch(e){/*ignore*/}
    if (scriptNode) { scriptNode.disconnect(); scriptNode = null; }
    if (analyser) { analyser.disconnect(); analyser = null; }
    if (audioContext) { audioContext.close(); audioContext = null; }

    freqBuffer = [];
    lastShownFreq = null;
    lastDisplayTime = 0;
    resultEl.textContent = '-- Hz';
    debugEl.textContent = '';
    console.log('Stopped recording');
  }

  function processFrame() {
    const bufferLen = analyser.fftSize;
    const byteBuf = new Uint8Array(bufferLen);
    analyser.getByteTimeDomainData(byteBuf);

    // convert 0..255 -> -1..1
    const floatBuf = new Float32Array(bufferLen);
    let sumAbs = 0;
    for (let i = 0; i < bufferLen; i++) {
      const v = (byteBuf[i] - 128) / 128;
      floatBuf[i] = v;
      sumAbs += Math.abs(v);
    }
    const meanAbs = sumAbs / bufferLen;

    // update noise floor (slow EMA)
    const alpha = 0.02;
    noiseFloor = noiseFloor * (1 - alpha) + meanAbs * alpha;
    const triggerThreshold = Math.max(MIN_VOLUME, noiseFloor * 2.2);

    if (meanAbs < triggerThreshold) {
      const now = performance.now();
      if (lastShownFreq && (now - lastDisplayTime) < HOLD_MS) {
        // hold value
      } else {
        resultEl.textContent = '-- Hz';
        lastShownFreq = null;
      }
      if (LOG) debugEl.textContent = `meanAbs:${meanAbs.toFixed(4)} thr:${triggerThreshold.toFixed(4)} nf:${noiseFloor.toFixed(4)}`;
      return;
    }

    // we have a hit candidate — estimate fundamental via autocorrelation
    const rawFreq = autoCorrelate(floatBuf, audioContext.sampleRate);
    if (rawFreq === -1) {
      const now = performance.now();
      if (lastShownFreq && (now - lastDisplayTime) < HOLD_MS) {
        // hold
      } else {
        resultEl.textContent = '-- Hz';
        lastShownFreq = null;
      }
      return;
    }

    // harmonic correction: try dividing down to fit in DRUM_MIN..DRUM_MAX
    const corrected = harmonicCorrect(rawFreq, DRUM_MIN, DRUM_MAX);

    if (corrected && corrected >= 20 && corrected <= 4000) {
      pushAndShowFrequency(corrected);
      if (LOG) debugEl.textContent = `raw:${rawFreq.toFixed(1)} corrected:${corrected.toFixed(1)} meanAbs:${meanAbs.toFixed(4)}`;
    } else {
      // fallback
      pushAndShowFrequency(rawFreq);
      if (LOG) debugEl.textContent = `raw:${rawFreq.toFixed(1)} (no correct) meanAbs:${meanAbs.toFixed(4)}`;
    }
  }

  // smoothing: median + small EMA
  function pushAndShowFrequency(freq) {
    if (!isFinite(freq) || freq <= 0 || freq > 20000) return;

    freqBuffer.push(freq);
    if (freqBuffer.length > SMOOTH_WINDOW) freqBuffer.shift();

    const sorted = freqBuffer.slice().sort((a,b)=>a-b);
    const median = sorted[Math.floor(sorted.length/2)];

    const displayed = lastShownFreq || median;
    const smooth = displayed * 0.55 + median * 0.45;

    // clamp weird spikes: jump limiter (avoid >2x jumps)
    let final = smooth;
    if (lastShownFreq && smooth > lastShownFreq * 2.5) final = lastShownFreq; // ignore huge jump
    if (lastShownFreq && smooth < lastShownFreq * 0.35) final = lastShownFreq;  // ignore huge drop

    resultEl.textContent = Math.round(final) + ' Hz';
    lastShownFreq = final;
    lastDisplayTime = performance.now();
  }

  // harmonic correction by integer divisors + small tolerance for inharmonicity
  function harmonicCorrect(freq, minTarget, maxTarget) {
    if (freq <= 0 || !isFinite(freq)) return null;
    // First, if freq already in range, keep it
    if (freq >= minTarget && freq <= maxTarget) return freq;

    // try dividing by integer divisors 2..12 (higher divisors for kicks)
    for (let d = 2; d <= 12; d++) {
      const cand = freq / d;
      if (cand >= minTarget && cand <= maxTarget) {
        // sanity check: prefer smaller d (lower harmonic)
        return cand;
      }
    }

    // if none found, attempt tolerance-based match: divisors with ~10% wiggle for inharmonicity
    const TOLERANCE = 0.12; // 12%
    for (let d = 2; d <= 12; d++) {
      const cand = freq / d;
      // if cand is close to the band (within tolerance)
      if (cand >= minTarget*(1 - TOLERANCE) && cand <= maxTarget*(1 + TOLERANCE)) {
        // clamp into band
        return Math.min(Math.max(cand, minTarget), maxTarget);
      }
    }

    // fallback: try to bias toward lower region — repeatedly divide until under maxTarget
    let f = freq;
    while (f > maxTarget && f > 20) {
      f = f / 2;
      if (f >= minTarget && f <= maxTarget) return f;
    }

    // give up — return original
    return freq;
  }

  // robust autocorrelation adapted for larger windows
  function autoCorrelate(buf, sampleRate) {
    const SIZE = buf.length;
    let rms = 0;
    for (let i = 0; i < SIZE; i++) {
      const val = buf[i];
      rms += val * val;
    }
    rms = Math.sqrt(rms / SIZE);
    if (rms < 0.0018) return -1; // too quiet

    // trim quiet edges
    let r1 = 0, r2 = SIZE - 1;
    const th = Math.max(0.01, rms * 0.25);
    for (let i = 0; i < SIZE/2; i++) {
      if (Math.abs(buf[i]) < th) { r1 = i; break; }
    }
    for (let i = 1; i < SIZE/2; i++) {
      if (Math.abs(buf[SIZE - i]) < th) { r2 = SIZE - i; break; }
    }
    const trimmed = buf.subarray(r1, r2);
    const N = trimmed.length;
    if (N < 128) return -1;

    // autocorrelation
    const ac = new Float32Array(N);
    for (let lag = 0; lag < N; lag++) {
      let sum = 0;
      for (let i = 0; i < N - lag; i++) {
        sum += trimmed[i] * trimmed[i + lag];
      }
      ac[lag] = sum;
    }

    // search best lag in reasonable range (for drums we allow 20Hz..3000Hz)
    const minFreq = 20;
    const maxFreq = 4000;
    const minLag = Math.floor(sampleRate / maxFreq);
    const maxLag = Math.min(N - 2, Math.floor(sampleRate / minFreq));

    let best = -1, bestVal = -Infinity;
    for (let lag = Math.max(2, minLag); lag <= maxLag; lag++) {
      if (ac[lag] > bestVal) {
        bestVal = ac[lag];
        best = lag;
      }
    }

    if (best <= 0 || bestVal <= 0) return -1;

    // parabolic interpolation around best for sub-sample accuracy
    const y0 = ac[best - 1] || 0;
    const y1 = ac[best];
    const y2 = ac[best + 1] || 0;
    const denom = (y0 - 2*y1 + y2);
    let shift = 0;
    if (denom !== 0) shift = (y0 - y2) / (2 * denom);
    const refinedLag = best + shift;
    if (refinedLag <= 0) return -1;

    const frequency = sampleRate / refinedLag;
    return frequency;
  }

});
</script>
</body>
</html>
